"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_app-shell_tsx",{

/***/ "(app-pages-browser)/./src/lib/offline-db.ts":
/*!*******************************!*\
  !*** ./src/lib/offline-db.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addOfflineItem: () => (/* binding */ addOfflineItem),\n/* harmony export */   addToSyncQueue: () => (/* binding */ addToSyncQueue),\n/* harmony export */   cacheCategories: () => (/* binding */ cacheCategories),\n/* harmony export */   cacheProducts: () => (/* binding */ cacheProducts),\n/* harmony export */   clearAllOfflineData: () => (/* binding */ clearAllOfflineData),\n/* harmony export */   clearSyncQueue: () => (/* binding */ clearSyncQueue),\n/* harmony export */   completeOfflineOrder: () => (/* binding */ completeOfflineOrder),\n/* harmony export */   createOfflineOrder: () => (/* binding */ createOfflineOrder),\n/* harmony export */   deleteOfflineOrder: () => (/* binding */ deleteOfflineOrder),\n/* harmony export */   generateOfflineId: () => (/* binding */ generateOfflineId),\n/* harmony export */   getCacheAge: () => (/* binding */ getCacheAge),\n/* harmony export */   getCachedCategories: () => (/* binding */ getCachedCategories),\n/* harmony export */   getCachedProducts: () => (/* binding */ getCachedProducts),\n/* harmony export */   getOfflineOrders: () => (/* binding */ getOfflineOrders),\n/* harmony export */   getPendingOfflineOrders: () => (/* binding */ getPendingOfflineOrders),\n/* harmony export */   getProductsByCategory: () => (/* binding */ getProductsByCategory),\n/* harmony export */   getSyncQueue: () => (/* binding */ getSyncQueue),\n/* harmony export */   removeSyncItem: () => (/* binding */ removeSyncItem),\n/* harmony export */   searchCachedProducts: () => (/* binding */ searchCachedProducts),\n/* harmony export */   updateOfflineItemQty: () => (/* binding */ updateOfflineItemQty),\n/* harmony export */   updateOfflineOrderSync: () => (/* binding */ updateOfflineOrderSync),\n/* harmony export */   voidOfflineItem: () => (/* binding */ voidOfflineItem)\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ cacheProducts,cacheCategories,getCachedProducts,getCachedCategories,getProductsByCategory,searchCachedProducts,getCacheAge,generateOfflineId,createOfflineOrder,addOfflineItem,voidOfflineItem,updateOfflineItemQty,completeOfflineOrder,getOfflineOrders,getPendingOfflineOrders,deleteOfflineOrder,updateOfflineOrderSync,addToSyncQueue,getSyncQueue,removeSyncItem,clearSyncQueue,clearAllOfflineData auto */ /**\n * ═══════════════════════════════════════════════\n * TSH Restaurantes — Offline Database (IndexedDB)\n * ═══════════════════════════════════════════════\n * Local storage for POS offline mode:\n * - Products & categories cached for offline browsing\n * - Orders created offline with temp IDs\n * - Sync queue for pending mutations\n */ const DB_NAME = 'tsh-pos-offline';\nconst DB_VERSION = 1;\n// ─── STORES ───\nconst STORES = {\n    products: 'products',\n    categories: 'categories',\n    orders: 'offline_orders',\n    syncQueue: 'sync_queue',\n    meta: 'meta'\n};\n// ─── OPEN DB ───\nfunction openDB() {\n    return new Promise((resolve, reject)=>{\n        const req = indexedDB.open(DB_NAME, DB_VERSION);\n        req.onupgradeneeded = (e)=>{\n            const db = e.target.result;\n            if (!db.objectStoreNames.contains(STORES.products)) {\n                const ps = db.createObjectStore(STORES.products, {\n                    keyPath: 'id'\n                });\n                ps.createIndex('categoryId', 'categoryId', {\n                    unique: false\n                });\n                ps.createIndex('name', 'name', {\n                    unique: false\n                });\n            }\n            if (!db.objectStoreNames.contains(STORES.categories)) {\n                db.createObjectStore(STORES.categories, {\n                    keyPath: 'id'\n                });\n            }\n            if (!db.objectStoreNames.contains(STORES.orders)) {\n                const os = db.createObjectStore(STORES.orders, {\n                    keyPath: 'id'\n                });\n                os.createIndex('status', 'status', {\n                    unique: false\n                });\n                os.createIndex('createdAt', 'createdAt', {\n                    unique: false\n                });\n            }\n            if (!db.objectStoreNames.contains(STORES.syncQueue)) {\n                const sq = db.createObjectStore(STORES.syncQueue, {\n                    keyPath: 'id',\n                    autoIncrement: true\n                });\n                sq.createIndex('timestamp', 'timestamp', {\n                    unique: false\n                });\n            }\n            if (!db.objectStoreNames.contains(STORES.meta)) {\n                db.createObjectStore(STORES.meta, {\n                    keyPath: 'key'\n                });\n            }\n        };\n        req.onsuccess = ()=>resolve(req.result);\n        req.onerror = ()=>reject(req.error);\n    });\n}\n// ─── GENERIC HELPERS ───\nasync function getAll(storeName) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readonly');\n        const store = tx.objectStore(storeName);\n        const req = store.getAll();\n        req.onsuccess = ()=>resolve(req.result);\n        req.onerror = ()=>reject(req.error);\n    });\n}\nasync function getOne(storeName, key) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readonly');\n        const store = tx.objectStore(storeName);\n        const req = store.get(key);\n        req.onsuccess = ()=>resolve(req.result || null);\n        req.onerror = ()=>reject(req.error);\n    });\n}\nasync function putOne(storeName, data) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readwrite');\n        const store = tx.objectStore(storeName);\n        store.put(data);\n        tx.oncomplete = ()=>resolve();\n        tx.onerror = ()=>reject(tx.error);\n    });\n}\nasync function putMany(storeName, items) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readwrite');\n        const store = tx.objectStore(storeName);\n        items.forEach((item)=>store.put(item));\n        tx.oncomplete = ()=>resolve();\n        tx.onerror = ()=>reject(tx.error);\n    });\n}\nasync function deleteOne(storeName, key) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readwrite');\n        const store = tx.objectStore(storeName);\n        store.delete(key);\n        tx.oncomplete = ()=>resolve();\n        tx.onerror = ()=>reject(tx.error);\n    });\n}\nasync function clearStore(storeName) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(storeName, 'readwrite');\n        const store = tx.objectStore(storeName);\n        store.clear();\n        tx.oncomplete = ()=>resolve();\n        tx.onerror = ()=>reject(tx.error);\n    });\n}\n// ═══════════════════════════════════════\n// PRODUCTS & CATEGORIES\n// ═══════════════════════════════════════\nasync function cacheProducts(products) {\n    await clearStore(STORES.products);\n    await putMany(STORES.products, products);\n    await putOne(STORES.meta, {\n        key: 'products_cached_at',\n        value: Date.now()\n    });\n}\nasync function cacheCategories(categories) {\n    await clearStore(STORES.categories);\n    await putMany(STORES.categories, categories);\n    await putOne(STORES.meta, {\n        key: 'categories_cached_at',\n        value: Date.now()\n    });\n}\nasync function getCachedProducts() {\n    return getAll(STORES.products);\n}\nasync function getCachedCategories() {\n    return getAll(STORES.categories);\n}\nasync function getProductsByCategory(categoryId) {\n    const db = await openDB();\n    return new Promise((resolve, reject)=>{\n        const tx = db.transaction(STORES.products, 'readonly');\n        const store = tx.objectStore(STORES.products);\n        const index = store.index('categoryId');\n        const req = index.getAll(categoryId);\n        req.onsuccess = ()=>resolve(req.result);\n        req.onerror = ()=>reject(req.error);\n    });\n}\nasync function searchCachedProducts(query) {\n    const all = await getAll(STORES.products);\n    const q = query.toLowerCase();\n    return all.filter((p)=>{\n        var _p_name, _p_sku;\n        return ((_p_name = p.name) === null || _p_name === void 0 ? void 0 : _p_name.toLowerCase().includes(q)) || ((_p_sku = p.sku) === null || _p_sku === void 0 ? void 0 : _p_sku.toLowerCase().includes(q));\n    });\n}\nasync function getCacheAge() {\n    const pMeta = await getOne(STORES.meta, 'products_cached_at');\n    const cMeta = await getOne(STORES.meta, 'categories_cached_at');\n    return {\n        products: (pMeta === null || pMeta === void 0 ? void 0 : pMeta.value) || null,\n        categories: (cMeta === null || cMeta === void 0 ? void 0 : cMeta.value) || null\n    };\n}\n// ═══════════════════════════════════════\n// OFFLINE ORDERS\n// ═══════════════════════════════════════\nfunction generateOfflineId() {\n    return \"offline-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).slice(2, 8));\n}\nasync function createOfflineOrder() {\n    let type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'dine_in', metadata = arguments.length > 1 ? arguments[1] : void 0;\n    const order = {\n        id: generateOfflineId(),\n        type,\n        status: 'open',\n        items: [],\n        subtotal: 0,\n        taxAmount: 0,\n        total: 0,\n        payments: [],\n        metadata,\n        createdAt: new Date().toISOString(),\n        _offline: true,\n        _syncStatus: 'pending'\n    };\n    await putOne(STORES.orders, order);\n    return order;\n}\nasync function addOfflineItem(orderId, product) {\n    let quantity = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, notes = arguments.length > 3 ? arguments[3] : void 0;\n    const order = await getOne(STORES.orders, orderId);\n    if (!order) return null;\n    const price = product.price || 0;\n    const existingIdx = order.items.findIndex((i)=>i.productId === product.id && i.status === 'active' && i.notes === (notes || ''));\n    if (existingIdx >= 0) {\n        // Merge quantities\n        order.items[existingIdx].quantity += quantity;\n        order.items[existingIdx].total = order.items[existingIdx].quantity * order.items[existingIdx].unitPrice;\n    } else {\n        order.items.push({\n            id: generateOfflineId(),\n            productId: product.id,\n            productName: product.name,\n            quantity,\n            unitPrice: price,\n            total: price * quantity,\n            notes: notes || undefined,\n            status: 'active'\n        });\n    }\n    recalcOfflineOrder(order);\n    await putOne(STORES.orders, order);\n    return order;\n}\nasync function voidOfflineItem(orderId, itemId) {\n    const order = await getOne(STORES.orders, orderId);\n    if (!order) return null;\n    const item = order.items.find((i)=>i.id === itemId);\n    if (item) item.status = 'voided';\n    recalcOfflineOrder(order);\n    await putOne(STORES.orders, order);\n    return order;\n}\nasync function updateOfflineItemQty(orderId, itemId, quantity) {\n    const order = await getOne(STORES.orders, orderId);\n    if (!order) return null;\n    const item = order.items.find((i)=>i.id === itemId);\n    if (item) {\n        item.quantity = quantity;\n        item.total = item.unitPrice * quantity;\n    }\n    recalcOfflineOrder(order);\n    await putOne(STORES.orders, order);\n    return order;\n}\nfunction recalcOfflineOrder(order) {\n    const activeItems = order.items.filter((i)=>i.status === 'active');\n    order.subtotal = activeItems.reduce((sum, i)=>sum + i.total, 0);\n    // Default 15% tax (from tenant settings ideally)\n    const taxRate = 0.15;\n    order.taxAmount = Math.round(order.subtotal * taxRate * 100) / 100;\n    order.total = Math.round((order.subtotal + order.taxAmount) * 100) / 100;\n}\nasync function completeOfflineOrder(orderId, payment) {\n    const order = await getOne(STORES.orders, orderId);\n    if (!order) return null;\n    order.status = 'completed';\n    order.payments.push({\n        id: generateOfflineId(),\n        method: payment.method,\n        amount: payment.amount,\n        cashReceived: payment.cashReceived,\n        paidAt: new Date().toISOString()\n    });\n    await putOne(STORES.orders, order);\n    return order;\n}\nasync function getOfflineOrders() {\n    return getAll(STORES.orders);\n}\nasync function getPendingOfflineOrders() {\n    const all = await getAll(STORES.orders);\n    return all.filter((o)=>o._syncStatus === 'pending' || o._syncStatus === 'error');\n}\nasync function deleteOfflineOrder(id) {\n    await deleteOne(STORES.orders, id);\n}\nasync function updateOfflineOrderSync(id, status, error) {\n    const order = await getOne(STORES.orders, id);\n    if (!order) return;\n    order._syncStatus = status;\n    if (error) order._syncError = error;\n    await putOne(STORES.orders, order);\n}\nasync function addToSyncQueue(action, payload) {\n    await putOne(STORES.syncQueue, {\n        action,\n        payload,\n        timestamp: Date.now(),\n        retries: 0\n    });\n}\nasync function getSyncQueue() {\n    return getAll(STORES.syncQueue);\n}\nasync function removeSyncItem(id) {\n    await deleteOne(STORES.syncQueue, id);\n}\nasync function clearSyncQueue() {\n    await clearStore(STORES.syncQueue);\n}\n// ═══════════════════════════════════════\n// FULL CLEAR\n// ═══════════════════════════════════════\nasync function clearAllOfflineData() {\n    await clearStore(STORES.products);\n    await clearStore(STORES.categories);\n    await clearStore(STORES.orders);\n    await clearStore(STORES.syncQueue);\n    await clearStore(STORES.meta);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvb2ZmbGluZS1kYi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytiQUVBOzs7Ozs7OztDQVFDLEdBRUQsTUFBTUEsVUFBVTtBQUNoQixNQUFNQyxhQUFhO0FBRW5CLGlCQUFpQjtBQUNqQixNQUFNQyxTQUFTO0lBQ2JDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxRQUFRO0lBQ1JDLFdBQVc7SUFDWEMsTUFBTTtBQUNSO0FBRUEsa0JBQWtCO0FBQ2xCLFNBQVNDO0lBQ1AsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCLE1BQU1DLE1BQU1DLFVBQVVDLElBQUksQ0FBQ2QsU0FBU0M7UUFDcENXLElBQUlHLGVBQWUsR0FBRyxDQUFDQztZQUNyQixNQUFNQyxLQUFLLEVBQUdDLE1BQU0sQ0FBc0JDLE1BQU07WUFDaEQsSUFBSSxDQUFDRixHQUFHRyxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDbkIsT0FBT0MsUUFBUSxHQUFHO2dCQUNsRCxNQUFNbUIsS0FBS0wsR0FBR00saUJBQWlCLENBQUNyQixPQUFPQyxRQUFRLEVBQUU7b0JBQUVxQixTQUFTO2dCQUFLO2dCQUNqRUYsR0FBR0csV0FBVyxDQUFDLGNBQWMsY0FBYztvQkFBRUMsUUFBUTtnQkFBTTtnQkFDM0RKLEdBQUdHLFdBQVcsQ0FBQyxRQUFRLFFBQVE7b0JBQUVDLFFBQVE7Z0JBQU07WUFDakQ7WUFDQSxJQUFJLENBQUNULEdBQUdHLGdCQUFnQixDQUFDQyxRQUFRLENBQUNuQixPQUFPRSxVQUFVLEdBQUc7Z0JBQ3BEYSxHQUFHTSxpQkFBaUIsQ0FBQ3JCLE9BQU9FLFVBQVUsRUFBRTtvQkFBRW9CLFNBQVM7Z0JBQUs7WUFDMUQ7WUFDQSxJQUFJLENBQUNQLEdBQUdHLGdCQUFnQixDQUFDQyxRQUFRLENBQUNuQixPQUFPRyxNQUFNLEdBQUc7Z0JBQ2hELE1BQU1zQixLQUFLVixHQUFHTSxpQkFBaUIsQ0FBQ3JCLE9BQU9H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YiwwQ0FBMEM7QUFFbkMsZUFBZXNJO0lBQ3BCLE1BQU14RixXQUFXbEQsT0FBT0MsUUFBUTtJQUNoQyxNQUFNaUQsV0FBV2xELE9BQU9FLFVBQVU7SUFDbEMsTUFBTWdELFdBQVdsRCxPQUFPRyxNQUFNO0lBQzlCLE1BQU0rQyxXQUFXbEQsT0FBT0ksU0FBUztJQUNqQyxNQUFNOEMsV0FBV2xELE9BQU9LLElBQUk7QUFDOUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jYXJsb3NhbW9yZXMvRG9jdW1lbnRzL1Byb3llY3Rvcy9wb3Mtc2FzL2FwcHMvd2ViL3NyYy9saWIvb2ZmbGluZS1kYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbi8qKlxuICog4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gKiBUU0ggUmVzdGF1cmFudGVzIOKAlCBPZmZsaW5lIERhdGFiYXNlIChJbmRleGVkREIpXG4gKiDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAqIExvY2FsIHN0b3JhZ2UgZm9yIFBPUyBvZmZsaW5lIG1vZGU6XG4gKiAtIFByb2R1Y3RzICYgY2F0ZWdvcmllcyBjYWNoZWQgZm9yIG9mZmxpbmUgYnJvd3NpbmdcbiAqIC0gT3JkZXJzIGNyZWF0ZWQgb2ZmbGluZSB3aXRoIHRlbXAgSURzXG4gKiAtIFN5bmMgcXVldWUgZm9yIHBlbmRpbmcgbXV0YXRpb25zXG4gKi9cblxuY29uc3QgREJfTkFNRSA9ICd0c2gtcG9zLW9mZmxpbmUnO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5cbi8vIOKUgOKUgOKUgCBTVE9SRVMg4pSA4pSA4pSAXG5jb25zdCBTVE9SRVMgPSB7XG4gIHByb2R1Y3RzOiAncHJvZHVjdHMnLFxuICBjYXRlZ29yaWVzOiAnY2F0ZWdvcmllcycsXG4gIG9yZGVyczogJ29mZmxpbmVfb3JkZXJzJyxcbiAgc3luY1F1ZXVlOiAnc3luY19xdWV1ZScsXG4gIG1ldGE6ICdtZXRhJywgLy8gZm9yIHRpbWVzdGFtcHMsIGNvbmZpZ1xufTtcblxuLy8g4pSA4pSA4pSAIE9QRU4gREIg4pSA4pSA4pSAXG5mdW5jdGlvbiBvcGVuREIoKTogUHJvbWlzZTxJREJEYXRhYmFzZT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcSA9IGluZGV4ZWREQi5vcGVuKERCX05BTUUsIERCX1ZFUlNJT04pO1xuICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgZGIgPSAoZS50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0O1xuICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFNUT1JFUy5wcm9kdWN0cykpIHtcbiAgICAgICAgY29uc3QgcHMgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRVMucHJvZHVjdHMsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgcHMuY3JlYXRlSW5kZXgoJ2NhdGVnb3J5SWQnLCAnY2F0ZWdvcnlJZCcsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgcHMuY3JlYXRlSW5kZXgoJ25hbWUnLCAnbmFtZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMuY2F0ZWdvcmllcykpIHtcbiAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLmNhdGVnb3JpZXMsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMub3JkZXJzKSkge1xuICAgICAgICBjb25zdCBvcyA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFUy5vcmRlcnMsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgb3MuY3JlYXRlSW5kZXgoJ3N0YXR1cycsICdzdGF0dXMnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgIG9zLmNyZWF0ZUluZGV4KCdjcmVhdGVkQXQnLCAnY3JlYXRlZEF0JywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFNUT1JFUy5zeW5jUXVldWUpKSB7XG4gICAgICAgIGNvbnN0IHNxID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLnN5bmNRdWV1ZSwgeyBrZXlQYXRoOiAnaWQnLCBhdXRvSW5jcmVtZW50OiB0cnVlIH0pO1xuICAgICAgICBzcS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhTVE9SRVMubWV0YSkpIHtcbiAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVTLm1ldGEsIHsga2V5UGF0aDogJ2tleScgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXEub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXEucmVzdWx0KTtcbiAgICByZXEub25lcnJvciA9ICgpID0+IHJlamVjdChyZXEuZXJyb3IpO1xuICB9KTtcbn1cblxuLy8g4pSA4pSA4pSAIEdFTkVSSUMgSEVMUEVSUyDilIDilIDilIBcblxuYXN5bmMgZnVuY3Rpb24gZ2V0QWxsPFQ+KHN0b3JlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUW10+IHtcbiAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgJ3JlYWRvbmx5Jyk7XG4gICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgIGNvbnN0IHJlcSA9IHN0b3JlLmdldEFsbCgpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgIHJlcS5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcS5lcnJvcik7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRPbmU8VD4oc3RvcmVOYW1lOiBzdHJpbmcsIGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IG9wZW5EQigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCAncmVhZG9ubHknKTtcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgY29uc3QgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG4gICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxLnJlc3VsdCB8fCBudWxsKTtcbiAgICByZXEub25lcnJvciA9ICgpID0+IHJlamVjdChyZXEuZXJyb3IpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHV0T25lKHN0b3JlTmFtZTogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IHN0b3JlID0gdHgub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBzdG9yZS5wdXQoZGF0YSk7XG4gICAgdHgub25jb21wbGV0ZSA9ICgpID0+IHJlc29sdmUoKTtcbiAgICB0eC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHR4LmVycm9yKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHB1dE1hbnkoc3RvcmVOYW1lOiBzdHJpbmcsIGl0ZW1zOiBhbnlbXSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IG9wZW5EQigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCAncmVhZHdyaXRlJyk7XG4gICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiBzdG9yZS5wdXQoaXRlbSkpO1xuICAgIHR4Lm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgdHgub25lcnJvciA9ICgpID0+IHJlamVjdCh0eC5lcnJvcik7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVPbmUoc3RvcmVOYW1lOiBzdHJpbmcsIGtleTogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gYXdhaXQgb3BlbkRCKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihzdG9yZU5hbWUsICdyZWFkd3JpdGUnKTtcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgdHgub25jb21wbGV0ZSA9ICgpID0+IHJlc29sdmUoKTtcbiAgICB0eC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHR4LmVycm9yKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNsZWFyU3RvcmUoc3RvcmVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IHN0b3JlID0gdHgub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBzdG9yZS5jbGVhcigpO1xuICAgIHR4Lm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgdHgub25lcnJvciA9ICgpID0+IHJlamVjdCh0eC5lcnJvcik7XG4gIH0pO1xufVxuXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbi8vIFBST0RVQ1RTICYgQ0FURUdPUklFU1xuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWNoZVByb2R1Y3RzKHByb2R1Y3RzOiBhbnlbXSk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBjbGVhclN0b3JlKFNUT1JFUy5wcm9kdWN0cyk7XG4gIGF3YWl0IHB1dE1hbnkoU1RPUkVTLnByb2R1Y3RzLCBwcm9kdWN0cyk7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMubWV0YSwgeyBrZXk6ICdwcm9kdWN0c19jYWNoZWRfYXQnLCB2YWx1ZTogRGF0ZS5ub3coKSB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhY2hlQ2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBhbnlbXSk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBjbGVhclN0b3JlKFNUT1JFUy5jYXRlZ29yaWVzKTtcbiAgYXdhaXQgcHV0TWFueShTVE9SRVMuY2F0ZWdvcmllcywgY2F0ZWdvcmllcyk7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMubWV0YSwgeyBrZXk6ICdjYXRlZ29yaWVzX2NhY2hlZF9hdCcsIHZhbHVlOiBEYXRlLm5vdygpIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkUHJvZHVjdHMoKTogUHJvbWlzZTxhbnlbXT4ge1xuICByZXR1cm4gZ2V0QWxsKFNUT1JFUy5wcm9kdWN0cyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWNoZWRDYXRlZ29yaWVzKCk6IFByb21pc2U8YW55W10+IHtcbiAgcmV0dXJuIGdldEFsbChTVE9SRVMuY2F0ZWdvcmllcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9kdWN0c0J5Q2F0ZWdvcnkoY2F0ZWdvcnlJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICBjb25zdCBkYiA9IGF3YWl0IG9wZW5EQigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVTLnByb2R1Y3RzLCAncmVhZG9ubHknKTtcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFUy5wcm9kdWN0cyk7XG4gICAgY29uc3QgaW5kZXggPSBzdG9yZS5pbmRleCgnY2F0ZWdvcnlJZCcpO1xuICAgIGNvbnN0IHJlcSA9IGluZGV4LmdldEFsbChjYXRlZ29yeUlkKTtcbiAgICByZXEub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXEucmVzdWx0KTtcbiAgICByZXEub25lcnJvciA9ICgpID0+IHJlamVjdChyZXEuZXJyb3IpO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaENhY2hlZFByb2R1Y3RzKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gIGNvbnN0IGFsbCA9IGF3YWl0IGdldEFsbDxhbnk+KFNUT1JFUy5wcm9kdWN0cyk7XG4gIGNvbnN0IHEgPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gYWxsLmZpbHRlcihwID0+XG4gICAgcC5uYW1lPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHEpIHx8XG4gICAgcC5za3U/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocSlcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhY2hlQWdlKCk6IFByb21pc2U8eyBwcm9kdWN0czogbnVtYmVyIHwgbnVsbDsgY2F0ZWdvcmllczogbnVtYmVyIHwgbnVsbCB9PiB7XG4gIGNvbnN0IHBNZXRhID0gYXdhaXQgZ2V0T25lPGFueT4oU1RPUkVTLm1ldGEsICdwcm9kdWN0c19jYWNoZWRfYXQnKTtcbiAgY29uc3QgY01ldGEgPSBhd2FpdCBnZXRPbmU8YW55PihTVE9SRVMubWV0YSwgJ2NhdGVnb3JpZXNfY2FjaGVkX2F0Jyk7XG4gIHJldHVybiB7XG4gICAgcHJvZHVjdHM6IHBNZXRhPy52YWx1ZSB8fCBudWxsLFxuICAgIGNhdGVnb3JpZXM6IGNNZXRhPy52YWx1ZSB8fCBudWxsLFxuICB9O1xufVxuXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbi8vIE9GRkxJTkUgT1JERVJTXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlT2ZmbGluZUlkKCk6IHN0cmluZyB7XG4gIHJldHVybiBgb2ZmbGluZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOCl9YDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lT3JkZXIge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHN0YXR1czogJ29wZW4nIHwgJ2NvbXBsZXRlZCc7XG4gIGl0ZW1zOiBPZmZsaW5lT3JkZXJJdGVtW107XG4gIHN1YnRvdGFsOiBudW1iZXI7XG4gIHRheEFtb3VudDogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYXltZW50czogYW55W107XG4gIG5vdGVzPzogc3RyaW5nO1xuICBtZXRhZGF0YT86IGFueTtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIF9vZmZsaW5lOiB0cnVlO1xuICBfc3luY1N0YXR1czogJ3BlbmRpbmcnIHwgJ3N5bmNpbmcnIHwgJ3N5bmNlZCcgfCAnZXJyb3InO1xuICBfc3luY0Vycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9mZmxpbmVPcmRlckl0ZW0ge1xuICBpZDogc3RyaW5nO1xuICBwcm9kdWN0SWQ6IHN0cmluZztcbiAgcHJvZHVjdE5hbWU6IHN0cmluZztcbiAgcXVhbnRpdHk6IG51bWJlcjtcbiAgdW5pdFByaWNlOiBudW1iZXI7XG4gIHRvdGFsOiBudW1iZXI7XG4gIG5vdGVzPzogc3RyaW5nO1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ3ZvaWRlZCc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVPZmZsaW5lT3JkZXIodHlwZTogc3RyaW5nID0gJ2RpbmVfaW4nLCBtZXRhZGF0YT86IGFueSk6IFByb21pc2U8T2ZmbGluZU9yZGVyPiB7XG4gIGNvbnN0IG9yZGVyOiBPZmZsaW5lT3JkZXIgPSB7XG4gICAgaWQ6IGdlbmVyYXRlT2ZmbGluZUlkKCksXG4gICAgdHlwZSxcbiAgICBzdGF0dXM6ICdvcGVuJyxcbiAgICBpdGVtczogW10sXG4gICAgc3VidG90YWw6IDAsXG4gICAgdGF4QW1vdW50OiAwLFxuICAgIHRvdGFsOiAwLFxuICAgIHBheW1lbnRzOiBbXSxcbiAgICBtZXRhZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBfb2ZmbGluZTogdHJ1ZSxcbiAgICBfc3luY1N0YXR1czogJ3BlbmRpbmcnLFxuICB9O1xuICBhd2FpdCBwdXRPbmUoU1RPUkVTLm9yZGVycywgb3JkZXIpO1xuICByZXR1cm4gb3JkZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRPZmZsaW5lSXRlbShcbiAgb3JkZXJJZDogc3RyaW5nLFxuICBwcm9kdWN0OiBhbnksXG4gIHF1YW50aXR5OiBudW1iZXIgPSAxLFxuICBub3Rlcz86IHN0cmluZ1xuKTogUHJvbWlzZTxPZmZsaW5lT3JkZXIgfCBudWxsPiB7XG4gIGNvbnN0IG9yZGVyID0gYXdhaXQgZ2V0T25lPE9mZmxpbmVPcmRlcj4oU1RPUkVTLm9yZGVycywgb3JkZXJJZCk7XG4gIGlmICghb3JkZXIpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHByaWNlID0gcHJvZHVjdC5wcmljZSB8fCAwO1xuICBjb25zdCBleGlzdGluZ0lkeCA9IG9yZGVyLml0ZW1zLmZpbmRJbmRleChcbiAgICBpID0+IGkucHJvZHVjdElkID09PSBwcm9kdWN0LmlkICYmIGkuc3RhdHVzID09PSAnYWN0aXZlJyAmJiBpLm5vdGVzID09PSAobm90ZXMgfHwgJycpXG4gICk7XG5cbiAgaWYgKGV4aXN0aW5nSWR4ID49IDApIHtcbiAgICAvLyBNZXJnZSBxdWFudGl0aWVzXG4gICAgb3JkZXIuaXRlbXNbZXhpc3RpbmdJZHhdLnF1YW50aXR5ICs9IHF1YW50aXR5O1xuICAgIG9yZGVyLml0ZW1zW2V4aXN0aW5nSWR4XS50b3RhbCA9IG9yZGVyLml0ZW1zW2V4aXN0aW5nSWR4XS5xdWFudGl0eSAqIG9yZGVyLml0ZW1zW2V4aXN0aW5nSWR4XS51bml0UHJpY2U7XG4gIH0gZWxzZSB7XG4gICAgb3JkZXIuaXRlbXMucHVzaCh7XG4gICAgICBpZDogZ2VuZXJhdGVPZmZsaW5lSWQoKSxcbiAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZCxcbiAgICAgIHByb2R1Y3ROYW1lOiBwcm9kdWN0Lm5hbWUsXG4gICAgICBxdWFudGl0eSxcbiAgICAgIHVuaXRQcmljZTogcHJpY2UsXG4gICAgICB0b3RhbDogcHJpY2UgKiBxdWFudGl0eSxcbiAgICAgIG5vdGVzOiBub3RlcyB8fCB1bmRlZmluZWQsXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgIH0pO1xuICB9XG5cbiAgcmVjYWxjT2ZmbGluZU9yZGVyKG9yZGVyKTtcbiAgYXdhaXQgcHV0T25lKFNUT1JFUy5vcmRlcnMsIG9yZGVyKTtcbiAgcmV0dXJuIG9yZGVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdm9pZE9mZmxpbmVJdGVtKG9yZGVySWQ6IHN0cmluZywgaXRlbUlkOiBzdHJpbmcpOiBQcm9taXNlPE9mZmxpbmVPcmRlciB8IG51bGw+IHtcbiAgY29uc3Qgb3JkZXIgPSBhd2FpdCBnZXRPbmU8T2ZmbGluZU9yZGVyPihTVE9SRVMub3JkZXJzLCBvcmRlcklkKTtcbiAgaWYgKCFvcmRlcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBvcmRlci5pdGVtcy5maW5kKGkgPT4gaS5pZCA9PT0gaXRlbUlkKTtcbiAgaWYgKGl0ZW0pIGl0ZW0uc3RhdHVzID0gJ3ZvaWRlZCc7XG4gIHJlY2FsY09mZmxpbmVPcmRlcihvcmRlcik7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMub3JkZXJzLCBvcmRlcik7XG4gIHJldHVybiBvcmRlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU9mZmxpbmVJdGVtUXR5KG9yZGVySWQ6IHN0cmluZywgaXRlbUlkOiBzdHJpbmcsIHF1YW50aXR5OiBudW1iZXIpOiBQcm9taXNlPE9mZmxpbmVPcmRlciB8IG51bGw+IHtcbiAgY29uc3Qgb3JkZXIgPSBhd2FpdCBnZXRPbmU8T2ZmbGluZU9yZGVyPihTVE9SRVMub3JkZXJzLCBvcmRlcklkKTtcbiAgaWYgKCFvcmRlcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBvcmRlci5pdGVtcy5maW5kKGkgPT4gaS5pZCA9PT0gaXRlbUlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICBpdGVtLnF1YW50aXR5ID0gcXVhbnRpdHk7XG4gICAgaXRlbS50b3RhbCA9IGl0ZW0udW5pdFByaWNlICogcXVhbnRpdHk7XG4gIH1cbiAgcmVjYWxjT2ZmbGluZU9yZGVyKG9yZGVyKTtcbiAgYXdhaXQgcHV0T25lKFNUT1JFUy5vcmRlcnMsIG9yZGVyKTtcbiAgcmV0dXJuIG9yZGVyO1xufVxuXG5mdW5jdGlvbiByZWNhbGNPZmZsaW5lT3JkZXIob3JkZXI6IE9mZmxpbmVPcmRlcikge1xuICBjb25zdCBhY3RpdmVJdGVtcyA9IG9yZGVyLml0ZW1zLmZpbHRlcihpID0+IGkuc3RhdHVzID09PSAnYWN0aXZlJyk7XG4gIG9yZGVyLnN1YnRvdGFsID0gYWN0aXZlSXRlbXMucmVkdWNlKChzdW0sIGkpID0+IHN1bSArIGkudG90YWwsIDApO1xuICAvLyBEZWZhdWx0IDE1JSB0YXggKGZyb20gdGVuYW50IHNldHRpbmdzIGlkZWFsbHkpXG4gIGNvbnN0IHRheFJhdGUgPSAwLjE1O1xuICBvcmRlci50YXhBbW91bnQgPSBNYXRoLnJvdW5kKG9yZGVyLnN1YnRvdGFsICogdGF4UmF0ZSAqIDEwMCkgLyAxMDA7XG4gIG9yZGVyLnRvdGFsID0gTWF0aC5yb3VuZCgob3JkZXIuc3VidG90YWwgKyBvcmRlci50YXhBbW91bnQpICogMTAwKSAvIDEwMDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlT2ZmbGluZU9yZGVyKG9yZGVySWQ6IHN0cmluZywgcGF5bWVudDoge1xuICBtZXRob2Q6IHN0cmluZzsgYW1vdW50OiBudW1iZXI7IGNhc2hSZWNlaXZlZD86IG51bWJlcjtcbn0pOiBQcm9taXNlPE9mZmxpbmVPcmRlciB8IG51bGw+IHtcbiAgY29uc3Qgb3JkZXIgPSBhd2FpdCBnZXRPbmU8T2ZmbGluZU9yZGVyPihTVE9SRVMub3JkZXJzLCBvcmRlcklkKTtcbiAgaWYgKCFvcmRlcikgcmV0dXJuIG51bGw7XG4gIG9yZGVyLnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xuICBvcmRlci5wYXltZW50cy5wdXNoKHtcbiAgICBpZDogZ2VuZXJhdGVPZmZsaW5lSWQoKSxcbiAgICBtZXRob2Q6IHBheW1lbnQubWV0aG9kLFxuICAgIGFtb3VudDogcGF5bWVudC5hbW91bnQsXG4gICAgY2FzaFJlY2VpdmVkOiBwYXltZW50LmNhc2hSZWNlaXZlZCxcbiAgICBwYWlkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfSk7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMub3JkZXJzLCBvcmRlcik7XG4gIHJldHVybiBvcmRlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9mZmxpbmVPcmRlcnMoKTogUHJvbWlzZTxPZmZsaW5lT3JkZXJbXT4ge1xuICByZXR1cm4gZ2V0QWxsPE9mZmxpbmVPcmRlcj4oU1RPUkVTLm9yZGVycyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZW5kaW5nT2ZmbGluZU9yZGVycygpOiBQcm9taXNlPE9mZmxpbmVPcmRlcltdPiB7XG4gIGNvbnN0IGFsbCA9IGF3YWl0IGdldEFsbDxPZmZsaW5lT3JkZXI+KFNUT1JFUy5vcmRlcnMpO1xuICByZXR1cm4gYWxsLmZpbHRlcihvID0+IG8uX3N5bmNTdGF0dXMgPT09ICdwZW5kaW5nJyB8fCBvLl9zeW5jU3RhdHVzID09PSAnZXJyb3InKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU9mZmxpbmVPcmRlcihpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGRlbGV0ZU9uZShTVE9SRVMub3JkZXJzLCBpZCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVPZmZsaW5lT3JkZXJTeW5jKGlkOiBzdHJpbmcsIHN0YXR1czogT2ZmbGluZU9yZGVyWydfc3luY1N0YXR1cyddLCBlcnJvcj86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBvcmRlciA9IGF3YWl0IGdldE9uZTxPZmZsaW5lT3JkZXI+KFNUT1JFUy5vcmRlcnMsIGlkKTtcbiAgaWYgKCFvcmRlcikgcmV0dXJuO1xuICBvcmRlci5fc3luY1N0YXR1cyA9IHN0YXR1cztcbiAgaWYgKGVycm9yKSBvcmRlci5fc3luY0Vycm9yID0gZXJyb3I7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMub3JkZXJzLCBvcmRlcik7XG59XG5cbi8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuLy8gU1lOQyBRVUVVRSAoZ2VuZXJpYyBtdXRhdGlvbnMpXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuZXhwb3J0IGludGVyZmFjZSBTeW5jUXVldWVJdGVtIHtcbiAgaWQ/OiBudW1iZXI7XG4gIGFjdGlvbjogc3RyaW5nO1xuICBwYXlsb2FkOiBhbnk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICByZXRyaWVzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRUb1N5bmNRdWV1ZShhY3Rpb246IHN0cmluZywgcGF5bG9hZDogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IHB1dE9uZShTVE9SRVMuc3luY1F1ZXVlLCB7XG4gICAgYWN0aW9uLFxuICAgIHBheWxvYWQsXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIHJldHJpZXM6IDAsXG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3luY1F1ZXVlKCk6IFByb21pc2U8U3luY1F1ZXVlSXRlbVtdPiB7XG4gIHJldHVybiBnZXRBbGw8U3luY1F1ZXVlSXRlbT4oU1RPUkVTLnN5bmNRdWV1ZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVTeW5jSXRlbShpZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGRlbGV0ZU9uZShTVE9SRVMuc3luY1F1ZXVlLCBpZCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhclN5bmNRdWV1ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgY2xlYXJTdG9yZShTVE9SRVMuc3luY1F1ZXVlKTtcbn1cblxuLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4vLyBGVUxMIENMRUFSXG4vLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyQWxsT2ZmbGluZURhdGEoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGNsZWFyU3RvcmUoU1RPUkVTLnByb2R1Y3RzKTtcbiAgYXdhaXQgY2xlYXJTdG9yZShTVE9SRVMuY2F0ZWdvcmllcyk7XG4gIGF3YWl0IGNsZWFyU3RvcmUoU1RPUkVTLm9yZGVycyk7XG4gIGF3YWl0IGNsZWFyU3RvcmUoU1RPUkVTLnN5bmNRdWV1ZSk7XG4gIGF3YWl0IGNsZWFyU3RvcmUoU1RPUkVTLm1ldGEpO1xufVxuIl0sIm5hbWVzIjpbIkRCX05BTUUiLCJEQl9WRVJTSU9OIiwiU1RPUkVTIiwicHJvZHVjdHMiLCJjYXRlZ29yaWVzIiwib3JkZXJzIiwic3luY1F1ZXVlIiwibWV0YSIsIm9wZW5EQiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxIiwiaW5kZXhlZERCIiwib3BlbiIsIm9udXBncmFkZW5lZWRlZCIsImUiLCJkYiIsInRhcmdldCIsInJlc3VsdCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsInBzIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJrZXlQYXRoIiwiY3JlYXRlSW5kZXgiLCJ1bmlxdWUiLCJvcyIsInNxIiwiYXV0b0luY3JlbWVudCIsIm9uc3VjY2VzcyIsIm9uZXJyb3IiLCJlcnJvciIsImdldEFsbCIsInN0b3JlTmFtZSIsInR4IiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwiZ2V0T25lIiwia2V5IiwiZ2V0IiwicHV0T25lIiwiZGF0YSIsInB1dCIsIm9uY29tcGxldGUiLCJwdXRNYW55IiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbSIsImRlbGV0ZU9uZSIsImRlbGV0ZSIsImNsZWFyU3RvcmUiLCJjbGVhciIsImNhY2hlUHJvZHVjdHMiLCJ2YWx1ZSIsIkRhdGUiLCJub3ciLCJjYWNoZUNhdGVnb3JpZXMiLCJnZXRDYWNoZWRQcm9kdWN0cyIsImdldENhY2hlZENhdGVnb3JpZXMiLCJnZXRQcm9kdWN0c0J5Q2F0ZWdvcnkiLCJjYXRlZ29yeUlkIiwiaW5kZXgiLCJzZWFyY2hDYWNoZWRQcm9kdWN0cyIsInF1ZXJ5IiwiYWxsIiwicSIsInRvTG93ZXJDYXNlIiwiZmlsdGVyIiwicCIsIm5hbWUiLCJpbmNsdWRlcyIsInNrdSIsImdldENhY2hlQWdlIiwicE1ldGEiLCJjTWV0YSIsImdlbmVyYXRlT2ZmbGluZUlkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJjcmVhdGVPZmZsaW5lT3JkZXIiLCJ0eXBlIiwibWV0YWRhdGEiLCJvcmRlciIsImlkIiwic3RhdHVzIiwic3VidG90YWwiLCJ0YXhBbW91bnQiLCJ0b3RhbCIsInBheW1lbnRzIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJfb2ZmbGluZSIsIl9zeW5jU3RhdHVzIiwiYWRkT2ZmbGluZUl0ZW0iLCJvcmRlcklkIiwicHJvZHVjdCIsInF1YW50aXR5Iiwibm90ZXMiLCJwcmljZSIsImV4aXN0aW5nSWR4IiwiZmluZEluZGV4IiwiaSIsInByb2R1Y3RJZCIsInVuaXRQcmljZSIsInB1c2giLCJwcm9kdWN0TmFtZSIsInVuZGVmaW5lZCIsInJlY2FsY09mZmxpbmVPcmRlciIsInZvaWRPZmZsaW5lSXRlbSIsIml0ZW1JZCIsImZpbmQiLCJ1cGRhdGVPZmZsaW5lSXRlbVF0eSIsImFjdGl2ZUl0ZW1zIiwicmVkdWNlIiwic3VtIiwidGF4UmF0ZSIsInJvdW5kIiwiY29tcGxldGVPZmZsaW5lT3JkZXIiLCJwYXltZW50IiwibWV0aG9kIiwiYW1vdW50IiwiY2FzaFJlY2VpdmVkIiwicGFpZEF0IiwiZ2V0T2ZmbGluZU9yZGVycyIsImdldFBlbmRpbmdPZmZsaW5lT3JkZXJzIiwibyIsImRlbGV0ZU9mZmxpbmVPcmRlciIsInVwZGF0ZU9mZmxpbmVPcmRlclN5bmMiLCJfc3luY0Vycm9yIiwiYWRkVG9TeW5jUXVldWUiLCJhY3Rpb24iLCJwYXlsb2FkIiwidGltZXN0YW1wIiwicmV0cmllcyIsImdldFN5bmNRdWV1ZSIsInJlbW92ZVN5bmNJdGVtIiwiY2xlYXJTeW5jUXVldWUiLCJjbGVhckFsbE9mZmxpbmVEYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/offline-db.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/offline-sync.ts":
/*!*********************************!*\
  !*** ./src/lib/offline-sync.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addItemOfflineAware: () => (/* binding */ addItemOfflineAware),\n/* harmony export */   createOrderOfflineAware: () => (/* binding */ createOrderOfflineAware),\n/* harmony export */   getOfflineCacheStatus: () => (/* binding */ getOfflineCacheStatus),\n/* harmony export */   loadCategoriesOfflineAware: () => (/* binding */ loadCategoriesOfflineAware),\n/* harmony export */   loadProductsOfflineAware: () => (/* binding */ loadProductsOfflineAware),\n/* harmony export */   processPaymentOfflineAware: () => (/* binding */ processPaymentOfflineAware),\n/* harmony export */   refreshOfflineCache: () => (/* binding */ refreshOfflineCache),\n/* harmony export */   syncOfflineOrders: () => (/* binding */ syncOfflineOrders),\n/* harmony export */   voidItemOfflineAware: () => (/* binding */ voidItemOfflineAware)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/use-offline */ \"(app-pages-browser)/./src/lib/use-offline.ts\");\n/* harmony import */ var _lib_offline_db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/offline-db */ \"(app-pages-browser)/./src/lib/offline-db.ts\");\n/* __next_internal_client_entry_do_not_use__ refreshOfflineCache,loadProductsOfflineAware,loadCategoriesOfflineAware,createOrderOfflineAware,addItemOfflineAware,voidItemOfflineAware,processPaymentOfflineAware,syncOfflineOrders,getOfflineCacheStatus auto */ /**\n * ═══════════════════════════════════════════════\n * TSH Restaurantes — Offline Sync Manager\n * ═══════════════════════════════════════════════\n * Bridges the POS store with offline capabilities:\n * - Caches products/categories to IndexedDB when online\n * - Falls back to IndexedDB when offline\n * - Creates offline orders that sync when connection returns\n * - Manages sync queue with retry logic\n */ \n\n\n// ─── CACHE PRODUCTS & CATEGORIES ───\nasync function refreshOfflineCache() {\n    try {\n        const [products, categories] = await Promise.all([\n            _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.get('/products?limit=500'),\n            _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.getCategories()\n        ]);\n        const productList = Array.isArray(products) ? products : (products === null || products === void 0 ? void 0 : products.data) || [];\n        const categoryList = Array.isArray(categories) ? categories : [];\n        await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.cacheProducts)(productList);\n        await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.cacheCategories)(categoryList);\n        console.log(\"[Offline] Cached \".concat(productList.length, \" products, \").concat(categoryList.length, \" categories\"));\n        return {\n            products: productList.length,\n            categories: categoryList.length\n        };\n    } catch (e) {\n        console.warn('[Offline] Failed to refresh cache:', e);\n        return {\n            products: 0,\n            categories: 0\n        };\n    }\n}\n// ─── OFFLINE-AWARE LOADERS ───\nasync function loadProductsOfflineAware(categoryId, search) {\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    if (isOnline) {\n        try {\n            const params = new URLSearchParams();\n            if (categoryId) params.set('categoryId', categoryId);\n            if (search) params.set('search', search);\n            const result = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.get(\"/products\".concat(params.toString() ? '?' + params : ''));\n            const products = Array.isArray(result) ? result : (result === null || result === void 0 ? void 0 : result.data) || [];\n            // Update cache in background\n            (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.cacheProducts)(products).catch(()=>{});\n            return products;\n        } catch (e) {\n        // Network failed, fall through to cache\n        }\n    }\n    // Offline or network failed — use cache\n    console.log('[Offline] Loading products from cache');\n    if (search) return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.searchCachedProducts)(search);\n    return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCachedProducts)();\n}\nasync function loadCategoriesOfflineAware() {\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    if (isOnline) {\n        try {\n            const categories = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.getCategories();\n            const list = Array.isArray(categories) ? categories : [];\n            (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.cacheCategories)(list).catch(()=>{});\n            return list;\n        } catch (e) {}\n    }\n    console.log('[Offline] Loading categories from cache');\n    return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCachedCategories)();\n}\n// ─── OFFLINE ORDER CREATION ───\nasync function createOrderOfflineAware() {\n    let type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'dine_in', metadata = arguments.length > 1 ? arguments[1] : void 0;\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    if (isOnline) {\n        try {\n            return await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.createOrder({\n                type,\n                metadata\n            });\n        } catch (e) {}\n    }\n    console.log('[Offline] Creating offline order');\n    return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.createOfflineOrder)(type, metadata);\n}\nasync function addItemOfflineAware(order, productId) {\n    let quantity = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, notes = arguments.length > 3 ? arguments[3] : void 0;\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    // Online order (has real ID)\n    if (isOnline && !order._offline) {\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.addOrderItem(order.id, {\n                productId,\n                quantity,\n                notes\n            });\n            return _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.getOrder(order.id);\n        } catch (e) {}\n    }\n    // Offline order — need product data to calculate\n    let product;\n    if (isOnline) {\n        try {\n            product = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.get(\"/products/\".concat(productId));\n        } catch (e) {}\n    }\n    if (!product) {\n        // Find in cache\n        const cached = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCachedProducts)();\n        product = cached.find((p)=>p.id === productId);\n    }\n    if (!product) {\n        throw new Error('Producto no disponible offline');\n    }\n    return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.addOfflineItem)(order.id, product, quantity, notes);\n}\nasync function voidItemOfflineAware(order, itemId, reason) {\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    if (isOnline && !order._offline) {\n        try {\n            return await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.voidOrderItem(order.id, itemId, reason);\n        } catch (e) {}\n    }\n    return (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.voidOfflineItem)(order.id, itemId);\n}\nasync function processPaymentOfflineAware(order, method, amount, cashReceived) {\n    const isOnline = _lib_use_offline__WEBPACK_IMPORTED_MODULE_1__.useOfflineStore.getState().isOnline;\n    if (isOnline && !order._offline) {\n        try {\n            return await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.processPayment(order.id, {\n                method,\n                amount,\n                cashReceived\n            });\n        } catch (e) {}\n    }\n    // Complete offline — will sync later\n    console.log('[Offline] Completing order offline');\n    const completed = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.completeOfflineOrder)(order.id, {\n        method,\n        amount,\n        cashReceived\n    });\n    return {\n        orderStatus: 'completed',\n        _offline: true,\n        change: method === 'cash' && cashReceived ? Math.max(0, (cashReceived || 0) - amount) : 0,\n        order: completed\n    };\n}\n// ─── SYNC OFFLINE ORDERS ───\nasync function syncOfflineOrders() {\n    const pending = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getPendingOfflineOrders)();\n    if (pending.length === 0) return {\n        synced: 0,\n        failed: 0,\n        pending: 0\n    };\n    console.log(\"[Offline] Syncing \".concat(pending.length, \" offline orders...\"));\n    let synced = 0;\n    let failed = 0;\n    for (const offlineOrder of pending){\n        try {\n            await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.updateOfflineOrderSync)(offlineOrder.id, 'syncing');\n            // 1. Create order on server\n            const serverOrder = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.createOrder({\n                type: offlineOrder.type,\n                metadata: {\n                    ...offlineOrder.metadata,\n                    _offlineId: offlineOrder.id,\n                    _offlineCreatedAt: offlineOrder.createdAt\n                }\n            });\n            // 2. Add items\n            const activeItems = offlineOrder.items.filter((i)=>i.status === 'active');\n            for (const item of activeItems){\n                await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.addOrderItem(serverOrder.id, {\n                    productId: item.productId,\n                    quantity: item.quantity,\n                    notes: item.notes\n                });\n            }\n            // 3. Process payment if completed\n            if (offlineOrder.status === 'completed' && offlineOrder.payments.length > 0) {\n                const payment = offlineOrder.payments[0];\n                await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.processPayment(serverOrder.id, {\n                    method: payment.method,\n                    amount: payment.amount,\n                    cashReceived: payment.cashReceived\n                });\n            }\n            // 4. Mark as synced and remove\n            await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.updateOfflineOrderSync)(offlineOrder.id, 'synced');\n            // Keep for 1 hour then clean up\n            setTimeout(()=>(0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.deleteOfflineOrder)(offlineOrder.id), 3600000);\n            synced++;\n        } catch (e) {\n            console.error(\"[Offline] Failed to sync order \".concat(offlineOrder.id, \":\"), e.message);\n            await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.updateOfflineOrderSync)(offlineOrder.id, 'error', e.message);\n            failed++;\n        }\n    }\n    console.log(\"[Offline] Sync done: \".concat(synced, \" synced, \").concat(failed, \" failed\"));\n    return {\n        synced,\n        failed,\n        pending: pending.length - synced - failed\n    };\n}\n// ─── CACHE STATUS ───\nasync function getOfflineCacheStatus() {\n    const products = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCachedProducts)();\n    const categories = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCachedCategories)();\n    const pending = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getPendingOfflineOrders)();\n    const cacheAge = await (0,_lib_offline_db__WEBPACK_IMPORTED_MODULE_2__.getCacheAge)();\n    return {\n        hasProducts: products.length > 0,\n        hasCategories: categories.length > 0,\n        productCount: products.length,\n        categoryCount: categories.length,\n        cacheAge,\n        pendingOrders: pending.length\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvb2ZmbGluZS1zeW5jLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztpUUFFQTs7Ozs7Ozs7O0NBU0MsR0FFK0I7QUFDb0I7QUFRMUI7QUFFMUIsc0NBQXNDO0FBRS9CLGVBQWVlO0lBQ3BCLElBQUk7UUFDRixNQUFNLENBQUNDLFVBQVVDLFdBQVcsR0FBRyxNQUFNQyxRQUFRQyxHQUFHLENBQUM7WUFDL0NuQix5Q0FBR0EsQ0FBQ29CLEdBQUcsQ0FBTTtZQUNicEIseUNBQUdBLENBQUNxQixhQUFhO1NBQ2xCO1FBRUQsTUFBTUMsY0FBY0MsTUFBTUMsT0FBTyxDQUFDUixZQUFZQSxXQUFZQSxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVTLElBQUksS0FBSSxFQUFFO1FBQzlFLE1BQU1DLGVBQWVILE1BQU1DLE9BQU8sQ0FBQ1AsY0FBY0EsYUFBYSxFQUFFO1FBRWhFLE1BQU1mLDhEQUFhQSxDQUFDb0I7UUFDcEIsTUFBTW5CLGdFQUFlQSxDQUFDdUI7UUFFdEJDLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0RGLE9BQWhDSixZQUFZTyxNQUFNLEVBQUMsZUFBaUMsT0FBcEJILGFBQWFHLE1BQU0sRUFBQztRQUNwRixPQUFPO1lBQUViLFVBQVVNLFlBQVlPLE1BQU07WUFBRVosWUFBWVMsYUFBYUcsTUFBTTtRQUFDO0lBQ3pFLEVBQUUsT0FBT0MsR0FBRztRQUNWSCxRQUFRSSxJQUFJLENBQUMsc0NBQXNDRDtRQUNuRCxPQUFPO1lBQUVkLFVBQVU7WUFBR0MsWUFBWTtRQUFFO0lBQ3RDO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFFekIsZUFBZWUseUJBQXlCQyxVQUFtQixFQUFFQyxNQUFlO0lBQ2pGLE1BQU1DLFdBQVdsQyw2REFBZUEsQ0FBQ21DLFFBQVEsR0FBR0QsUUFBUTtJQUVwRCxJQUFJQSxVQUFVO1FBQ1osSUFBSTtZQUNGLE1BQU1FLFNBQVMsSUFBSUM7WUFDbkIsSUFBSUwsWUFBWUksT0FBT0UsR0FBRyxD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LGFBQWF6QixFQUFFLEVBQUU7WUFDOUMsZ0NBQWdDO1lBQ2hDc0MsV0FBVyxJQUFNakYsbUVBQWtCQSxDQUFDb0UsYUFBYXpCLEVBQUUsR0FBRztZQUN0RHVCO1FBQ0YsRUFBRSxPQUFPakQsR0FBUTtZQUNmSCxRQUFRb0UsS0FBSyxDQUFDLGtDQUFrRCxPQUFoQmQsYUFBYXpCLEVBQUUsRUFBQyxNQUFJMUIsRUFBRWtFLE9BQU87WUFDN0UsTUFBTXBGLHVFQUFzQkEsQ0FBQ3FFLGFBQWF6QixFQUFFLEVBQUUsU0FBUzFCLEVBQUVrRSxPQUFPO1lBQ2hFaEI7UUFDRjtJQUNGO0lBRUFyRCxRQUFRQyxHQUFHLENBQUMsd0JBQTBDb0QsT0FBbEJELFFBQU8sYUFBa0IsT0FBUEMsUUFBTztJQUM3RCxPQUFPO1FBQUVEO1FBQVFDO1FBQVFGLFNBQVNBLFFBQVFqRCxNQUFNLEdBQUdrRCxTQUFTQztJQUFPO0FBQ3JFO0FBRUEsdUJBQXVCO0FBRWhCLGVBQWVpQjtJQVFwQixNQUFNakYsV0FBVyxNQUFNWixrRUFBaUJBO0lBQ3hDLE1BQU1hLGFBQWEsTUFBTVosb0VBQW1CQTtJQUM1QyxNQUFNeUUsVUFBVSxNQUFNbkUsd0VBQXVCQTtJQUM3QyxNQUFNdUYsV0FBVyxNQUFNcEYsNERBQVdBO0lBRWxDLE9BQU87UUFDTHFGLGFBQWFuRixTQUFTYSxNQUFNLEdBQUc7UUFDL0J1RSxlQUFlbkYsV0FBV1ksTUFBTSxHQUFHO1FBQ25Dd0UsY0FBY3JGLFNBQVNhLE1BQU07UUFDN0J5RSxlQUFlckYsV0FBV1ksTUFBTTtRQUNoQ3FFO1FBQ0FLLGVBQWV6QixRQUFRakQsTUFBTTtJQUMvQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvY2FybG9zYW1vcmVzL0RvY3VtZW50cy9Qcm95ZWN0b3MvcG9zLXNhcy9hcHBzL3dlYi9zcmMvbGliL29mZmxpbmUtc3luYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbi8qKlxuICog4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gKiBUU0ggUmVzdGF1cmFudGVzIOKAlCBPZmZsaW5lIFN5bmMgTWFuYWdlclxuICog4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gKiBCcmlkZ2VzIHRoZSBQT1Mgc3RvcmUgd2l0aCBvZmZsaW5lIGNhcGFiaWxpdGllczpcbiAqIC0gQ2FjaGVzIHByb2R1Y3RzL2NhdGVnb3JpZXMgdG8gSW5kZXhlZERCIHdoZW4gb25saW5lXG4gKiAtIEZhbGxzIGJhY2sgdG8gSW5kZXhlZERCIHdoZW4gb2ZmbGluZVxuICogLSBDcmVhdGVzIG9mZmxpbmUgb3JkZXJzIHRoYXQgc3luYyB3aGVuIGNvbm5lY3Rpb24gcmV0dXJuc1xuICogLSBNYW5hZ2VzIHN5bmMgcXVldWUgd2l0aCByZXRyeSBsb2dpY1xuICovXG5cbmltcG9ydCB7IGFwaSB9IGZyb20gJ0AvbGliL2FwaSc7XG5pbXBvcnQgeyB1c2VPZmZsaW5lU3RvcmUgfSBmcm9tICdAL2xpYi91c2Utb2ZmbGluZSc7XG5pbXBvcnQge1xuICBjYWNoZVByb2R1Y3RzLCBjYWNoZUNhdGVnb3JpZXMsXG4gIGdldENhY2hlZFByb2R1Y3RzLCBnZXRDYWNoZWRDYXRlZ29yaWVzLCBzZWFyY2hDYWNoZWRQcm9kdWN0cyxcbiAgY3JlYXRlT2ZmbGluZU9yZGVyLCBhZGRPZmZsaW5lSXRlbSwgdm9pZE9mZmxpbmVJdGVtLFxuICBjb21wbGV0ZU9mZmxpbmVPcmRlciwgZ2V0UGVuZGluZ09mZmxpbmVPcmRlcnMsXG4gIHVwZGF0ZU9mZmxpbmVPcmRlclN5bmMsIGRlbGV0ZU9mZmxpbmVPcmRlciwgZ2V0Q2FjaGVBZ2UsXG4gIHR5cGUgT2ZmbGluZU9yZGVyLFxufSBmcm9tICdAL2xpYi9vZmZsaW5lLWRiJztcblxuLy8g4pSA4pSA4pSAIENBQ0hFIFBST0RVQ1RTICYgQ0FURUdPUklFUyDilIDilIDilIBcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hPZmZsaW5lQ2FjaGUoKTogUHJvbWlzZTx7IHByb2R1Y3RzOiBudW1iZXI7IGNhdGVnb3JpZXM6IG51bWJlciB9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgW3Byb2R1Y3RzLCBjYXRlZ29yaWVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGFwaS5nZXQ8YW55PignL3Byb2R1Y3RzP2xpbWl0PTUwMCcpLFxuICAgICAgYXBpLmdldENhdGVnb3JpZXMoKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHByb2R1Y3RMaXN0ID0gQXJyYXkuaXNBcnJheShwcm9kdWN0cykgPyBwcm9kdWN0cyA6IChwcm9kdWN0cz8uZGF0YSB8fCBbXSk7XG4gICAgY29uc3QgY2F0ZWdvcnlMaXN0ID0gQXJyYXkuaXNBcnJheShjYXRlZ29yaWVzKSA/IGNhdGVnb3JpZXMgOiBbXTtcblxuICAgIGF3YWl0IGNhY2hlUHJvZHVjdHMocHJvZHVjdExpc3QpO1xuICAgIGF3YWl0IGNhY2hlQ2F0ZWdvcmllcyhjYXRlZ29yeUxpc3QpO1xuXG4gICAgY29uc29sZS5sb2coYFtPZmZsaW5lXSBDYWNoZWQgJHtwcm9kdWN0TGlzdC5sZW5ndGh9IHByb2R1Y3RzLCAke2NhdGVnb3J5TGlzdC5sZW5ndGh9IGNhdGVnb3JpZXNgKTtcbiAgICByZXR1cm4geyBwcm9kdWN0czogcHJvZHVjdExpc3QubGVuZ3RoLCBjYXRlZ29yaWVzOiBjYXRlZ29yeUxpc3QubGVuZ3RoIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tPZmZsaW5lXSBGYWlsZWQgdG8gcmVmcmVzaCBjYWNoZTonLCBlKTtcbiAgICByZXR1cm4geyBwcm9kdWN0czogMCwgY2F0ZWdvcmllczogMCB9O1xuICB9XG59XG5cbi8vIOKUgOKUgOKUgCBPRkZMSU5FLUFXQVJFIExPQURFUlMg4pSA4pSA4pSAXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUHJvZHVjdHNPZmZsaW5lQXdhcmUoY2F0ZWdvcnlJZD86IHN0cmluZywgc2VhcmNoPzogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICBjb25zdCBpc09ubGluZSA9IHVzZU9mZmxpbmVTdG9yZS5nZXRTdGF0ZSgpLmlzT25saW5lO1xuXG4gIGlmIChpc09ubGluZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICBpZiAoY2F0ZWdvcnlJZCkgcGFyYW1zLnNldCgnY2F0ZWdvcnlJZCcsIGNhdGVnb3J5SWQpO1xuICAgICAgaWYgKHNlYXJjaCkgcGFyYW1zLnNldCgnc2VhcmNoJywgc2VhcmNoKTtcbiAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0gYXdhaXQgYXBpLmdldChgL3Byb2R1Y3RzJHtwYXJhbXMudG9TdHJpbmcoKSA/ICc/JyArIHBhcmFtcyA6ICcnfWApO1xuICAgICAgY29uc3QgcHJvZHVjdHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiAocmVzdWx0Py5kYXRhIHx8IFtdKTtcbiAgICAgIC8vIFVwZGF0ZSBjYWNoZSBpbiBiYWNrZ3JvdW5kXG4gICAgICBjYWNoZVByb2R1Y3RzKHByb2R1Y3RzKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICByZXR1cm4gcHJvZHVjdHM7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBOZXR3b3JrIGZhaWxlZCwgZmFsbCB0aHJvdWdoIHRvIGNhY2hlXG4gICAgfVxuICB9XG5cbiAgLy8gT2ZmbGluZSBvciBuZXR3b3JrIGZhaWxlZCDigJQgdXNlIGNhY2hlXG4gIGNvbnNvbGUubG9nKCdbT2ZmbGluZV0gTG9hZGluZyBwcm9kdWN0cyBmcm9tIGNhY2hlJyk7XG4gIGlmIChzZWFyY2gpIHJldHVybiBzZWFyY2hDYWNoZWRQcm9kdWN0cyhzZWFyY2gpO1xuICByZXR1cm4gZ2V0Q2FjaGVkUHJvZHVjdHMoKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRDYXRlZ29yaWVzT2ZmbGluZUF3YXJlKCk6IFByb21pc2U8YW55W10+IHtcbiAgY29uc3QgaXNPbmxpbmUgPSB1c2VPZmZsaW5lU3RvcmUuZ2V0U3RhdGUoKS5pc09ubGluZTtcblxuICBpZiAoaXNPbmxpbmUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IGF3YWl0IGFwaS5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShjYXRlZ29yaWVzKSA/IGNhdGVnb3JpZXMgOiBbXTtcbiAgICAgIGNhY2hlQ2F0ZWdvcmllcyhsaXN0KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9IGNhdGNoIHt9XG4gIH1cblxuICBjb25zb2xlLmxvZygnW09mZmxpbmVdIExvYWRpbmcgY2F0ZWdvcmllcyBmcm9tIGNhY2hlJyk7XG4gIHJldHVybiBnZXRDYWNoZWRDYXRlZ29yaWVzKCk7XG59XG5cbi8vIOKUgOKUgOKUgCBPRkZMSU5FIE9SREVSIENSRUFUSU9OIOKUgOKUgOKUgFxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3JkZXJPZmZsaW5lQXdhcmUodHlwZTogc3RyaW5nID0gJ2RpbmVfaW4nLCBtZXRhZGF0YT86IGFueSk6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IGlzT25saW5lID0gdXNlT2ZmbGluZVN0b3JlLmdldFN0YXRlKCkuaXNPbmxpbmU7XG5cbiAgaWYgKGlzT25saW5lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGkuY3JlYXRlT3JkZXIoeyB0eXBlLCBtZXRhZGF0YSB9KTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cblxuICBjb25zb2xlLmxvZygnW09mZmxpbmVdIENyZWF0aW5nIG9mZmxpbmUgb3JkZXInKTtcbiAgcmV0dXJuIGNyZWF0ZU9mZmxpbmVPcmRlcih0eXBlLCBtZXRhZGF0YSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRJdGVtT2ZmbGluZUF3YXJlKG9yZGVyOiBhbnksIHByb2R1Y3RJZDogc3RyaW5nLCBxdWFudGl0eTogbnVtYmVyID0gMSwgbm90ZXM/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICBjb25zdCBpc09ubGluZSA9IHVzZU9mZmxpbmVTdG9yZS5nZXRTdGF0ZSgpLmlzT25saW5lO1xuXG4gIC8vIE9ubGluZSBvcmRlciAoaGFzIHJlYWwgSUQpXG4gIGlmIChpc09ubGluZSAmJiAhb3JkZXIuX29mZmxpbmUpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXBpLmFkZE9yZGVySXRlbShvcmRlci5pZCwgeyBwcm9kdWN0SWQsIHF1YW50aXR5LCBub3RlcyB9KTtcbiAgICAgIHJldHVybiBhcGkuZ2V0T3JkZXIob3JkZXIuaWQpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIC8vIE9mZmxpbmUgb3JkZXIg4oCUIG5lZWQgcHJvZHVjdCBkYXRhIHRvIGNhbGN1bGF0ZVxuICBsZXQgcHJvZHVjdDogYW55O1xuICBpZiAoaXNPbmxpbmUpIHtcbiAgICB0cnkge1xuICAgICAgcHJvZHVjdCA9IGF3YWl0IGFwaS5nZXQoYC9wcm9kdWN0cy8ke3Byb2R1Y3RJZH1gKTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgaWYgKCFwcm9kdWN0KSB7XG4gICAgLy8gRmluZCBpbiBjYWNoZVxuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IGdldENhY2hlZFByb2R1Y3RzKCk7XG4gICAgcHJvZHVjdCA9IGNhY2hlZC5maW5kKHAgPT4gcC5pZCA9PT0gcHJvZHVjdElkKTtcbiAgfVxuICBpZiAoIXByb2R1Y3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3RvIG5vIGRpc3BvbmlibGUgb2ZmbGluZScpO1xuICB9XG5cbiAgcmV0dXJuIGFkZE9mZmxpbmVJdGVtKG9yZGVyLmlkLCBwcm9kdWN0LCBxdWFudGl0eSwgbm90ZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdm9pZEl0ZW1PZmZsaW5lQXdhcmUob3JkZXI6IGFueSwgaXRlbUlkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgaXNPbmxpbmUgPSB1c2VPZmZsaW5lU3RvcmUuZ2V0U3RhdGUoKS5pc09ubGluZTtcblxuICBpZiAoaXNPbmxpbmUgJiYgIW9yZGVyLl9vZmZsaW5lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGkudm9pZE9yZGVySXRlbShvcmRlci5pZCwgaXRlbUlkLCByZWFzb24pO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIHJldHVybiB2b2lkT2ZmbGluZUl0ZW0ob3JkZXIuaWQsIGl0ZW1JZCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUGF5bWVudE9mZmxpbmVBd2FyZShvcmRlcjogYW55LCBtZXRob2Q6IHN0cmluZywgYW1vdW50OiBudW1iZXIsIGNhc2hSZWNlaXZlZD86IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IGlzT25saW5lID0gdXNlT2ZmbGluZVN0b3JlLmdldFN0YXRlKCkuaXNPbmxpbmU7XG5cbiAgaWYgKGlzT25saW5lICYmICFvcmRlci5fb2ZmbGluZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpLnByb2Nlc3NQYXltZW50KG9yZGVyLmlkLCB7IG1ldGhvZCwgYW1vdW50LCBjYXNoUmVjZWl2ZWQgfSk7XG4gICAgfSBjYXRjaCB7fVxuICB9XG5cbiAgLy8gQ29tcGxldGUgb2ZmbGluZSDigJQgd2lsbCBzeW5jIGxhdGVyXG4gIGNvbnNvbGUubG9nKCdbT2ZmbGluZV0gQ29tcGxldGluZyBvcmRlciBvZmZsaW5lJyk7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IGF3YWl0IGNvbXBsZXRlT2ZmbGluZU9yZGVyKG9yZGVyLmlkLCB7IG1ldGhvZCwgYW1vdW50LCBjYXNoUmVjZWl2ZWQgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBvcmRlclN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgX29mZmxpbmU6IHRydWUsXG4gICAgY2hhbmdlOiBtZXRob2QgPT09ICdjYXNoJyAmJiBjYXNoUmVjZWl2ZWQgPyBNYXRoLm1heCgwLCAoY2FzaFJlY2VpdmVkIHx8IDApIC0gYW1vdW50KSA6IDAsXG4gICAgb3JkZXI6IGNvbXBsZXRlZCxcbiAgfTtcbn1cblxuLy8g4pSA4pSA4pSAIFNZTkMgT0ZGTElORSBPUkRFUlMg4pSA4pSA4pSAXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jT2ZmbGluZU9yZGVycygpOiBQcm9taXNlPHsgc3luY2VkOiBudW1iZXI7IGZhaWxlZDogbnVtYmVyOyBwZW5kaW5nOiBudW1iZXIgfT4ge1xuICBjb25zdCBwZW5kaW5nID0gYXdhaXQgZ2V0UGVuZGluZ09mZmxpbmVPcmRlcnMoKTtcbiAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSByZXR1cm4geyBzeW5jZWQ6IDAsIGZhaWxlZDogMCwgcGVuZGluZzogMCB9O1xuXG4gIGNvbnNvbGUubG9nKGBbT2ZmbGluZV0gU3luY2luZyAke3BlbmRpbmcubGVuZ3RofSBvZmZsaW5lIG9yZGVycy4uLmApO1xuICBsZXQgc3luY2VkID0gMDtcbiAgbGV0IGZhaWxlZCA9IDA7XG5cbiAgZm9yIChjb25zdCBvZmZsaW5lT3JkZXIgb2YgcGVuZGluZykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB1cGRhdGVPZmZsaW5lT3JkZXJTeW5jKG9mZmxpbmVPcmRlci5pZCwgJ3N5bmNpbmcnKTtcblxuICAgICAgLy8gMS4gQ3JlYXRlIG9yZGVyIG9uIHNlcnZlclxuICAgICAgY29uc3Qgc2VydmVyT3JkZXI6IGFueSA9IGF3YWl0IGFwaS5jcmVhdGVPcmRlcih7XG4gICAgICAgIHR5cGU6IG9mZmxpbmVPcmRlci50eXBlLFxuICAgICAgICBtZXRhZGF0YTogeyAuLi5vZmZsaW5lT3JkZXIubWV0YWRhdGEsIF9vZmZsaW5lSWQ6IG9mZmxpbmVPcmRlci5pZCwgX29mZmxpbmVDcmVhdGVkQXQ6IG9mZmxpbmVPcmRlci5jcmVhdGVkQXQgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyAyLiBBZGQgaXRlbXNcbiAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gb2ZmbGluZU9yZGVyLml0ZW1zLmZpbHRlcihpID0+IGkuc3RhdHVzID09PSAnYWN0aXZlJyk7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWN0aXZlSXRlbXMpIHtcbiAgICAgICAgYXdhaXQgYXBpLmFkZE9yZGVySXRlbShzZXJ2ZXJPcmRlci5pZCwge1xuICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0SWQsXG4gICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXG4gICAgICAgICAgbm90ZXM6IGl0ZW0ubm90ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBQcm9jZXNzIHBheW1lbnQgaWYgY29tcGxldGVkXG4gICAgICBpZiAob2ZmbGluZU9yZGVyLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiYgb2ZmbGluZU9yZGVyLnBheW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGF5bWVudCA9IG9mZmxpbmVPcmRlci5wYXltZW50c1swXTtcbiAgICAgICAgYXdhaXQgYXBpLnByb2Nlc3NQYXltZW50KHNlcnZlck9yZGVyLmlkLCB7XG4gICAgICAgICAgbWV0aG9kOiBwYXltZW50Lm1ldGhvZCxcbiAgICAgICAgICBhbW91bnQ6IHBheW1lbnQuYW1vdW50LFxuICAgICAgICAgIGNhc2hSZWNlaXZlZDogcGF5bWVudC5jYXNoUmVjZWl2ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyA0LiBNYXJrIGFzIHN5bmNlZCBhbmQgcmVtb3ZlXG4gICAgICBhd2FpdCB1cGRhdGVPZmZsaW5lT3JkZXJTeW5jKG9mZmxpbmVPcmRlci5pZCwgJ3N5bmNlZCcpO1xuICAgICAgLy8gS2VlcCBmb3IgMSBob3VyIHRoZW4gY2xlYW4gdXBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZGVsZXRlT2ZmbGluZU9yZGVyKG9mZmxpbmVPcmRlci5pZCksIDM2MDAwMDApO1xuICAgICAgc3luY2VkKys7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbT2ZmbGluZV0gRmFpbGVkIHRvIHN5bmMgb3JkZXIgJHtvZmZsaW5lT3JkZXIuaWR9OmAsIGUubWVzc2FnZSk7XG4gICAgICBhd2FpdCB1cGRhdGVPZmZsaW5lT3JkZXJTeW5jKG9mZmxpbmVPcmRlci5pZCwgJ2Vycm9yJywgZS5tZXNzYWdlKTtcbiAgICAgIGZhaWxlZCsrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBbT2ZmbGluZV0gU3luYyBkb25lOiAke3N5bmNlZH0gc3luY2VkLCAke2ZhaWxlZH0gZmFpbGVkYCk7XG4gIHJldHVybiB7IHN5bmNlZCwgZmFpbGVkLCBwZW5kaW5nOiBwZW5kaW5nLmxlbmd0aCAtIHN5bmNlZCAtIGZhaWxlZCB9O1xufVxuXG4vLyDilIDilIDilIAgQ0FDSEUgU1RBVFVTIOKUgOKUgOKUgFxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0T2ZmbGluZUNhY2hlU3RhdHVzKCk6IFByb21pc2U8e1xuICBoYXNQcm9kdWN0czogYm9vbGVhbjtcbiAgaGFzQ2F0ZWdvcmllczogYm9vbGVhbjtcbiAgcHJvZHVjdENvdW50OiBudW1iZXI7XG4gIGNhdGVnb3J5Q291bnQ6IG51bWJlcjtcbiAgY2FjaGVBZ2U6IHsgcHJvZHVjdHM6IG51bWJlciB8IG51bGw7IGNhdGVnb3JpZXM6IG51bWJlciB8IG51bGwgfTtcbiAgcGVuZGluZ09yZGVyczogbnVtYmVyO1xufT4ge1xuICBjb25zdCBwcm9kdWN0cyA9IGF3YWl0IGdldENhY2hlZFByb2R1Y3RzKCk7XG4gIGNvbnN0IGNhdGVnb3JpZXMgPSBhd2FpdCBnZXRDYWNoZWRDYXRlZ29yaWVzKCk7XG4gIGNvbnN0IHBlbmRpbmcgPSBhd2FpdCBnZXRQZW5kaW5nT2ZmbGluZU9yZGVycygpO1xuICBjb25zdCBjYWNoZUFnZSA9IGF3YWl0IGdldENhY2hlQWdlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNQcm9kdWN0czogcHJvZHVjdHMubGVuZ3RoID4gMCxcbiAgICBoYXNDYXRlZ29yaWVzOiBjYXRlZ29yaWVzLmxlbmd0aCA+IDAsXG4gICAgcHJvZHVjdENvdW50OiBwcm9kdWN0cy5sZW5ndGgsXG4gICAgY2F0ZWdvcnlDb3VudDogY2F0ZWdvcmllcy5sZW5ndGgsXG4gICAgY2FjaGVBZ2UsXG4gICAgcGVuZGluZ09yZGVyczogcGVuZGluZy5sZW5ndGgsXG4gIH07XG59XG4iXSwibmFtZXMiOlsiYXBpIiwidXNlT2ZmbGluZVN0b3JlIiwiY2FjaGVQcm9kdWN0cyIsImNhY2hlQ2F0ZWdvcmllcyIsImdldENhY2hlZFByb2R1Y3RzIiwiZ2V0Q2FjaGVkQ2F0ZWdvcmllcyIsInNlYXJjaENhY2hlZFByb2R1Y3RzIiwiY3JlYXRlT2ZmbGluZU9yZGVyIiwiYWRkT2ZmbGluZUl0ZW0iLCJ2b2lkT2ZmbGluZUl0ZW0iLCJjb21wbGV0ZU9mZmxpbmVPcmRlciIsImdldFBlbmRpbmdPZmZsaW5lT3JkZXJzIiwidXBkYXRlT2ZmbGluZU9yZGVyU3luYyIsImRlbGV0ZU9mZmxpbmVPcmRlciIsImdldENhY2hlQWdlIiwicmVmcmVzaE9mZmxpbmVDYWNoZSIsInByb2R1Y3RzIiwiY2F0ZWdvcmllcyIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJnZXRDYXRlZ29yaWVzIiwicHJvZHVjdExpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJkYXRhIiwiY2F0ZWdvcnlMaXN0IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImUiLCJ3YXJuIiwibG9hZFByb2R1Y3RzT2ZmbGluZUF3YXJlIiwiY2F0ZWdvcnlJZCIsInNlYXJjaCIsImlzT25saW5lIiwiZ2V0U3RhdGUiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZXQiLCJyZXN1bHQiLCJ0b1N0cmluZyIsImNhdGNoIiwibG9hZENhdGVnb3JpZXNPZmZsaW5lQXdhcmUiLCJsaXN0IiwiY3JlYXRlT3JkZXJPZmZsaW5lQXdhcmUiLCJ0eXBlIiwibWV0YWRhdGEiLCJjcmVhdGVPcmRlciIsImFkZEl0ZW1PZmZsaW5lQXdhcmUiLCJvcmRlciIsInByb2R1Y3RJZCIsInF1YW50aXR5Iiwibm90ZXMiLCJfb2ZmbGluZSIsImFkZE9yZGVySXRlbSIsImlkIiwiZ2V0T3JkZXIiLCJwcm9kdWN0IiwiY2FjaGVkIiwiZmluZCIsInAiLCJFcnJvciIsInZvaWRJdGVtT2ZmbGluZUF3YXJlIiwiaXRlbUlkIiwicmVhc29uIiwidm9pZE9yZGVySXRlbSIsInByb2Nlc3NQYXltZW50T2ZmbGluZUF3YXJlIiwibWV0aG9kIiwiYW1vdW50IiwiY2FzaFJlY2VpdmVkIiwicHJvY2Vzc1BheW1lbnQiLCJjb21wbGV0ZWQiLCJvcmRlclN0YXR1cyIsImNoYW5nZSIsIk1hdGgiLCJtYXgiLCJzeW5jT2ZmbGluZU9yZGVycyIsInBlbmRpbmciLCJzeW5jZWQiLCJmYWlsZWQiLCJvZmZsaW5lT3JkZXIiLCJzZXJ2ZXJPcmRlciIsIl9vZmZsaW5lSWQiLCJfb2ZmbGluZUNyZWF0ZWRBdCIsImNyZWF0ZWRBdCIsImFjdGl2ZUl0ZW1zIiwiaXRlbXMiLCJmaWx0ZXIiLCJpIiwic3RhdHVzIiwiaXRlbSIsInBheW1lbnRzIiwicGF5bWVudCIsInNldFRpbWVvdXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJnZXRPZmZsaW5lQ2FjaGVTdGF0dXMiLCJjYWNoZUFnZSIsImhhc1Byb2R1Y3RzIiwiaGFzQ2F0ZWdvcmllcyIsInByb2R1Y3RDb3VudCIsImNhdGVnb3J5Q291bnQiLCJwZW5kaW5nT3JkZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/offline-sync.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/use-offline.ts":
/*!********************************!*\
  !*** ./src/lib/use-offline.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAutoPrecache: () => (/* binding */ useAutoPrecache),\n/* harmony export */   useInstallPrompt: () => (/* binding */ useInstallPrompt),\n/* harmony export */   useOfflineStore: () => (/* binding */ useOfflineStore),\n/* harmony export */   useOnlineStatus: () => (/* binding */ useOnlineStatus),\n/* harmony export */   usePrecacheData: () => (/* binding */ usePrecacheData),\n/* harmony export */   useServiceWorker: () => (/* binding */ useServiceWorker)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* __next_internal_client_entry_do_not_use__ useOfflineStore,useServiceWorker,useOnlineStatus,usePrecacheData,useAutoPrecache,useInstallPrompt auto */ \n\nconst QUEUE_KEY = 'pos-offline-queue';\nfunction loadQueue() {\n    if (false) {}\n    try {\n        return JSON.parse(localStorage.getItem(QUEUE_KEY) || '[]');\n    } catch (e) {\n        return [];\n    }\n}\nfunction saveQueue(queue) {\n    if (false) {}\n    localStorage.setItem(QUEUE_KEY, JSON.stringify(queue));\n}\nconst useOfflineStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        isOnline: typeof navigator !== 'undefined' ? navigator.onLine : true,\n        isServiceWorkerReady: false,\n        queuedActions: loadQueue(),\n        isSyncing: false,\n        lastSyncAt: null,\n        setOnline: (v)=>set({\n                isOnline: v\n            }),\n        setSWReady: (v)=>set({\n                isServiceWorkerReady: v\n            }),\n        addQueuedAction: (action)=>{\n            const queue = [\n                ...get().queuedActions,\n                action\n            ];\n            saveQueue(queue);\n            set({\n                queuedActions: queue\n            });\n        },\n        removeQueuedAction: (id)=>{\n            const queue = get().queuedActions.filter((a)=>a.id !== id);\n            saveQueue(queue);\n            set({\n                queuedActions: queue\n            });\n        },\n        clearQueue: ()=>{\n            saveQueue([]);\n            set({\n                queuedActions: []\n            });\n        },\n        setSyncing: (v)=>set({\n                isSyncing: v\n            }),\n        setLastSync: (ts)=>set({\n                lastSyncAt: ts\n            })\n    }));\n// ─── SERVICE WORKER REGISTRATION ───\nfunction useServiceWorker() {\n    const { setSWReady, addQueuedAction } = useOfflineStore();\n    const registered = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useServiceWorker.useEffect\": ()=>{\n            if ( false || !('serviceWorker' in navigator) || registered.current) return;\n            registered.current = true;\n            navigator.serviceWorker.register('/sw.js', {\n                scope: '/'\n            }).then({\n                \"useServiceWorker.useEffect\": (reg)=>{\n                    console.log('[PWA] SW registered, scope:', reg.scope);\n                    setSWReady(true);\n                    // Listen for updates\n                    reg.addEventListener('updatefound', {\n                        \"useServiceWorker.useEffect\": ()=>{\n                            const newWorker = reg.installing;\n                            if (!newWorker) return;\n                            newWorker.addEventListener('statechange', {\n                                \"useServiceWorker.useEffect\": ()=>{\n                                    if (newWorker.state === 'activated') {\n                                        console.log('[PWA] New SW activated — reload for updates');\n                                    // Optionally notify user of update\n                                    }\n                                }\n                            }[\"useServiceWorker.useEffect\"]);\n                        }\n                    }[\"useServiceWorker.useEffect\"]);\n                    // Check for updates periodically (every 30min)\n                    setInterval({\n                        \"useServiceWorker.useEffect\": ()=>reg.update()\n                    }[\"useServiceWorker.useEffect\"], 30 * 60 * 1000);\n                }\n            }[\"useServiceWorker.useEffect\"]).catch({\n                \"useServiceWorker.useEffect\": (err)=>{\n                    console.warn('[PWA] SW registration failed:', err);\n                }\n            }[\"useServiceWorker.useEffect\"]);\n            // Listen for messages from SW\n            navigator.serviceWorker.addEventListener('message', {\n                \"useServiceWorker.useEffect\": (event)=>{\n                    const { type, data } = event.data || {};\n                    if (type === 'QUEUE_STORE' && data) addQueuedAction(data);\n                    if (type === 'OFFLINE_QUEUED') console.log('[PWA] Queued offline:', data === null || data === void 0 ? void 0 : data.method, data === null || data === void 0 ? void 0 : data.url);\n                    if (type === 'SYNC_START') syncQueue();\n                }\n            }[\"useServiceWorker.useEffect\"]);\n        }\n    }[\"useServiceWorker.useEffect\"], []);\n}\n// ─── ONLINE/OFFLINE DETECTION ───\nfunction useOnlineStatus() {\n    const { isOnline, setOnline } = useOfflineStore();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useOnlineStatus.useEffect\": ()=>{\n            if (false) {}\n            const goOnline = {\n                \"useOnlineStatus.useEffect.goOnline\": ()=>{\n                    setOnline(true);\n                    syncQueue();\n                }\n            }[\"useOnlineStatus.useEffect.goOnline\"];\n            const goOffline = {\n                \"useOnlineStatus.useEffect.goOffline\": ()=>setOnline(false)\n            }[\"useOnlineStatus.useEffect.goOffline\"];\n            window.addEventListener('online', goOnline);\n            window.addEventListener('offline', goOffline);\n            setOnline(navigator.onLine);\n            return ({\n                \"useOnlineStatus.useEffect\": ()=>{\n                    window.removeEventListener('online', goOnline);\n                    window.removeEventListener('offline', goOffline);\n                }\n            })[\"useOnlineStatus.useEffect\"];\n        }\n    }[\"useOnlineStatus.useEffect\"], []);\n    return isOnline;\n}\n// ─── SYNC QUEUE ───\nasync function syncQueue() {\n    const store = useOfflineStore.getState();\n    if (store.isSyncing || store.queuedActions.length === 0 || !navigator.onLine) return;\n    store.setSyncing(true);\n    console.log(\"[PWA] Syncing \".concat(store.queuedActions.length, \" queued actions...\"));\n    const queue = [\n        ...store.queuedActions\n    ];\n    let synced = 0;\n    let failed = 0;\n    for (const action of queue){\n        try {\n            const response = await fetch(action.url, {\n                method: action.method,\n                headers: action.headers,\n                body: action.body\n            });\n            if (response.ok || response.status < 500) {\n                store.removeQueuedAction(action.id);\n                synced++;\n            } else {\n                failed++;\n            }\n        } catch (e) {\n            break;\n        }\n    }\n    store.setSyncing(false);\n    if (synced > 0) store.setLastSync(Date.now());\n    console.log(\"[PWA] Sync done: \".concat(synced, \" ok, \").concat(failed, \" failed, \").concat(queue.length - synced - failed, \" pending\"));\n    // Notify clients\n    if (synced > 0 && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {\n    // SW will broadcast update\n    }\n}\n// ─── PRE-CACHE API DATA ───\nfunction usePrecacheData() {\n    const cacheApiData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePrecacheData.useCallback[cacheApiData]\": (path, data)=>{\n            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) return;\n            // Build full URL from path\n            const url = path.startsWith('http') ? path : \"\".concat(window.location.origin).concat(path);\n            navigator.serviceWorker.controller.postMessage({\n                type: 'CACHE_API',\n                url,\n                data\n            });\n        }\n    }[\"usePrecacheData.useCallback[cacheApiData]\"], []);\n    const cachePage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePrecacheData.useCallback[cachePage]\": (url)=>{\n            if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) return;\n            navigator.serviceWorker.controller.postMessage({\n                type: 'CACHE_PAGE',\n                url\n            });\n        }\n    }[\"usePrecacheData.useCallback[cachePage]\"], []);\n    return {\n        cacheApiData,\n        cachePage\n    };\n}\n// ─── AUTO PRE-CACHE ON LOGIN ───\nfunction useAutoPrecache() {\n    const { cacheApiData, cachePage } = usePrecacheData();\n    const { isServiceWorkerReady } = useOfflineStore();\n    const precacheEssentials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAutoPrecache.useCallback[precacheEssentials]\": async ()=>{\n            if (!isServiceWorkerReady) return;\n            console.log('[PWA] Pre-caching essential data...');\n            // Cache key pages\n            [\n                '/pos',\n                '/kitchen',\n                '/tables',\n                '/dashboard',\n                '/waiter',\n                '/login'\n            ].forEach(cachePage);\n            // Cache API data\n            const token = localStorage.getItem('pos_token');\n            if (!token) return;\n            const API = \"http://localhost:3001\" || 0;\n            const headers = {\n                Authorization: \"Bearer \".concat(token),\n                'Content-Type': 'application/json'\n            };\n            const endpoints = [\n                '/products/categories',\n                '/products?limit=200',\n                '/customers?limit=100',\n                '/tenants/current'\n            ];\n            for (const ep of endpoints){\n                try {\n                    const res = await fetch(\"\".concat(API).concat(ep), {\n                        headers\n                    });\n                    if (res.ok) {\n                        const data = await res.json();\n                        cacheApiData(\"\".concat(API).concat(ep), data);\n                    }\n                } catch (e) {}\n            }\n            console.log('[PWA] Pre-cache done');\n        }\n    }[\"useAutoPrecache.useCallback[precacheEssentials]\"], [\n        isServiceWorkerReady,\n        cacheApiData,\n        cachePage\n    ]);\n    return {\n        precacheEssentials\n    };\n}\n// ─── INSTALL PROMPT ───\nfunction useInstallPrompt() {\n    const [deferredPrompt, setDeferredPrompt] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isInstallable, setIsInstallable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isInstalled, setIsInstalled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useInstallPrompt.useEffect\": ()=>{\n            if (false) {}\n            if (window.matchMedia('(display-mode: standalone)').matches) {\n                setIsInstalled(true);\n                return;\n            }\n            const handler = {\n                \"useInstallPrompt.useEffect.handler\": (e)=>{\n                    e.preventDefault();\n                    setDeferredPrompt(e);\n                    setIsInstallable(true);\n                }\n            }[\"useInstallPrompt.useEffect.handler\"];\n            window.addEventListener('beforeinstallprompt', handler);\n            window.addEventListener('appinstalled', {\n                \"useInstallPrompt.useEffect\": ()=>{\n                    setIsInstalled(true);\n                    setIsInstallable(false);\n                }\n            }[\"useInstallPrompt.useEffect\"]);\n            return ({\n                \"useInstallPrompt.useEffect\": ()=>window.removeEventListener('beforeinstallprompt', handler)\n            })[\"useInstallPrompt.useEffect\"];\n        }\n    }[\"useInstallPrompt.useEffect\"], []);\n    const install = async ()=>{\n        if (!deferredPrompt) return false;\n        deferredPrompt.prompt();\n        const result = await deferredPrompt.userChoice;\n        setDeferredPrompt(null);\n        setIsInstallable(false);\n        if (result.outcome === 'accepted') setIsInstalled(true);\n        return result.outcome === 'accepted';\n    };\n    return {\n        isInstallable,\n        isInstalled,\n        install\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXNlLW9mZmxpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3VKQUVpRTtBQUNoQztBQTRCakMsTUFBTUssWUFBWTtBQUVsQixTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUFVO0lBQzdDLElBQUk7UUFBRSxPQUFPQyxLQUFLQyxLQUFLLENBQUNDLGFBQWFDLE9BQU8sQ0FBQ0wsY0FBYztJQUFPLEVBQUUsVUFBTTtRQUFFLE9BQU8sRUFBRTtJQUFFO0FBQ3pGO0FBRUEsU0FBU00sVUFBVUMsS0FBcUI7SUFDdEMsSUFBSSxLQUE2QixFQUFFLEVBQU87SUFDMUNILGFBQWFJLE9BQU8sQ0FBQ1IsV0FBV0UsS0FBS08sU0FBUyxDQUFDRjtBQUNqRDtBQUVPLE1BQU1HLGtCQUFrQlgsK0NBQU1BLENBQWUsQ0FBQ1ksS0FBS0MsTUFBUztRQUNqRUMsVUFBVSxPQUFPQyxjQUFjLGNBQWNBLFVBQVVDLE1BQU0sR0FBRztRQUNoRUMsc0JBQXNCO1FBQ3RCQyxlQUFlaEI7UUFDZmlCLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxXQUFXLENBQUNDLElBQU1WLElBQUk7Z0JBQUVFLFVBQVVRO1lBQUU7UUFDcENDLFlBQVksQ0FBQ0QsSUFBTVYsSUFBSTtnQkFBRUssc0JBQXNCSztZQUFFO1FBQ2pERSxpQkFBaUIsQ0FBQ0M7WUFDaEIsTUFBTWpCLFFBQVE7bUJBQUlLLE1BQU1LLGFBQWE7Z0JBQUVPO2FBQU87WUFDOUNsQixVQUFVQztZQUNWSSxJQUFJO2dCQUFFTSxlQUFlVjtZQUFNO1FBQzdCO1FBQ0FrQixvQkFBb0IsQ0FBQ0M7WUFDbkIsTUFBTW5CLFFBQVFLLE1BQU1LLGFBQWEsQ0FBQ1UsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRixFQUFFLEtBQUtBO1lBQ3ZEcEIsVUFBVUM7WUFDVkksSUFBSTtnQkFBRU0sZUFBZVY7WUFBTTtRQUM3QjtRQUNBc0IsWUFBWTtZQUFRdkIsVUFBVSxFQUFFO1lBQUdL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TUMsU0FBUyxNQUFNYixlQUFlYyxVQUFVO1FBQzlDYixrQkFBa0I7UUFDbEJFLGlCQUFpQjtRQUNqQixJQUFJVSxPQUFPRSxPQUFPLEtBQUssWUFBWVYsZUFBZTtRQUNsRCxPQUFPUSxPQUFPRSxPQUFPLEtBQUs7SUFDNUI7SUFFQSxPQUFPO1FBQUViO1FBQWVFO1FBQWFPO0lBQVE7QUFDL0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jYXJsb3NhbW9yZXMvRG9jdW1lbnRzL1Byb3llY3Rvcy9wb3Mtc2FzL2FwcHMvd2ViL3NyYy9saWIvdXNlLW9mZmxpbmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5cbi8vIOKUgOKUgOKUgCBPRkZMSU5FIFNUT1JFIOKUgOKUgOKUgFxuXG5pbnRlcmZhY2UgT2ZmbGluZVN0YXRlIHtcbiAgaXNPbmxpbmU6IGJvb2xlYW47XG4gIGlzU2VydmljZVdvcmtlclJlYWR5OiBib29sZWFuO1xuICBxdWV1ZWRBY3Rpb25zOiBRdWV1ZWRBY3Rpb25bXTtcbiAgaXNTeW5jaW5nOiBib29sZWFuO1xuICBsYXN0U3luY0F0OiBudW1iZXIgfCBudWxsO1xuICBzZXRPbmxpbmU6ICh2OiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRTV1JlYWR5OiAodjogYm9vbGVhbikgPT4gdm9pZDtcbiAgYWRkUXVldWVkQWN0aW9uOiAoYWN0aW9uOiBRdWV1ZWRBY3Rpb24pID0+IHZvaWQ7XG4gIHJlbW92ZVF1ZXVlZEFjdGlvbjogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNsZWFyUXVldWU6ICgpID0+IHZvaWQ7XG4gIHNldFN5bmNpbmc6ICh2OiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRMYXN0U3luYzogKHRzOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVkQWN0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBib2R5OiBzdHJpbmcgfCBudWxsO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuY29uc3QgUVVFVUVfS0VZID0gJ3Bvcy1vZmZsaW5lLXF1ZXVlJztcblxuZnVuY3Rpb24gbG9hZFF1ZXVlKCk6IFF1ZXVlZEFjdGlvbltdIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG4gIHRyeSB7IHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFFVRVVFX0tFWSkgfHwgJ1tdJyk7IH0gY2F0Y2ggeyByZXR1cm4gW107IH1cbn1cblxuZnVuY3Rpb24gc2F2ZVF1ZXVlKHF1ZXVlOiBRdWV1ZWRBY3Rpb25bXSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUVVFVUVfS0VZLCBKU09OLnN0cmluZ2lmeShxdWV1ZSkpO1xufVxuXG5leHBvcnQgY29uc3QgdXNlT2ZmbGluZVN0b3JlID0gY3JlYXRlPE9mZmxpbmVTdGF0ZT4oKHNldCwgZ2V0KSA9PiAoe1xuICBpc09ubGluZTogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3Iub25MaW5lIDogdHJ1ZSxcbiAgaXNTZXJ2aWNlV29ya2VyUmVhZHk6IGZhbHNlLFxuICBxdWV1ZWRBY3Rpb25zOiBsb2FkUXVldWUoKSxcbiAgaXNTeW5jaW5nOiBmYWxzZSxcbiAgbGFzdFN5bmNBdDogbnVsbCxcbiAgc2V0T25saW5lOiAodikgPT4gc2V0KHsgaXNPbmxpbmU6IHYgfSksXG4gIHNldFNXUmVhZHk6ICh2KSA9PiBzZXQoeyBpc1NlcnZpY2VXb3JrZXJSZWFkeTogdiB9KSxcbiAgYWRkUXVldWVkQWN0aW9uOiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgcXVldWUgPSBbLi4uZ2V0KCkucXVldWVkQWN0aW9ucywgYWN0aW9uXTtcbiAgICBzYXZlUXVldWUocXVldWUpO1xuICAgIHNldCh7IHF1ZXVlZEFjdGlvbnM6IHF1ZXVlIH0pO1xuICB9LFxuICByZW1vdmVRdWV1ZWRBY3Rpb246IChpZCkgPT4ge1xuICAgIGNvbnN0IHF1ZXVlID0gZ2V0KCkucXVldWVkQWN0aW9ucy5maWx0ZXIoYSA9PiBhLmlkICE9PSBpZCk7XG4gICAgc2F2ZVF1ZXVlKHF1ZXVlKTtcbiAgICBzZXQoeyBxdWV1ZWRBY3Rpb25zOiBxdWV1ZSB9KTtcbiAgfSxcbiAgY2xlYXJRdWV1ZTogKCkgPT4geyBzYXZlUXVldWUoW10pOyBzZXQoeyBxdWV1ZWRBY3Rpb25zOiBbXSB9KTsgfSxcbiAgc2V0U3luY2luZzogKHYpID0+IHNldCh7IGlzU3luY2luZzogdiB9KSxcbiAgc2V0TGFzdFN5bmM6ICh0cykgPT4gc2V0KHsgbGFzdFN5bmNBdDogdHMgfSksXG59KSk7XG5cbi8vIOKUgOKUgOKUgCBTRVJWSUNFIFdPUktFUiBSRUdJU1RSQVRJT04g4pSA4pSA4pSAXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXJ2aWNlV29ya2VyKCkge1xuICBjb25zdCB7IHNldFNXUmVhZHksIGFkZFF1ZXVlZEFjdGlvbiB9ID0gdXNlT2ZmbGluZVN0b3JlKCk7XG4gIGNvbnN0IHJlZ2lzdGVyZWQgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikgfHwgcmVnaXN0ZXJlZC5jdXJyZW50KSByZXR1cm47XG4gICAgcmVnaXN0ZXJlZC5jdXJyZW50ID0gdHJ1ZTtcblxuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKCcvc3cuanMnLCB7IHNjb3BlOiAnLycgfSkudGhlbigocmVnKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnW1BXQV0gU1cgcmVnaXN0ZXJlZCwgc2NvcGU6JywgcmVnLnNjb3BlKTtcbiAgICAgIHNldFNXUmVhZHkodHJ1ZSk7XG5cbiAgICAgIC8vIExpc3RlbiBmb3IgdXBkYXRlc1xuICAgICAgcmVnLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWZvdW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdXb3JrZXIgPSByZWcuaW5zdGFsbGluZztcbiAgICAgICAgaWYgKCFuZXdXb3JrZXIpIHJldHVybjtcbiAgICAgICAgbmV3V29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChuZXdXb3JrZXIuc3RhdGUgPT09ICdhY3RpdmF0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1BXQV0gTmV3IFNXIGFjdGl2YXRlZCDigJQgcmVsb2FkIGZvciB1cGRhdGVzJyk7XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IG5vdGlmeSB1c2VyIG9mIHVwZGF0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHVwZGF0ZXMgcGVyaW9kaWNhbGx5IChldmVyeSAzMG1pbilcbiAgICAgIHNldEludGVydmFsKCgpID0+IHJlZy51cGRhdGUoKSwgMzAgKiA2MCAqIDEwMDApO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybignW1BXQV0gU1cgcmVnaXN0cmF0aW9uIGZhaWxlZDonLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBmcm9tIFNXXG4gICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBldmVudC5kYXRhIHx8IHt9O1xuICAgICAgaWYgKHR5cGUgPT09ICdRVUVVRV9TVE9SRScgJiYgZGF0YSkgYWRkUXVldWVkQWN0aW9uKGRhdGEpO1xuICAgICAgaWYgKHR5cGUgPT09ICdPRkZMSU5FX1FVRVVFRCcpIGNvbnNvbGUubG9nKCdbUFdBXSBRdWV1ZWQgb2ZmbGluZTonLCBkYXRhPy5tZXRob2QsIGRhdGE/LnVybCk7XG4gICAgICBpZiAodHlwZSA9PT0gJ1NZTkNfU1RBUlQnKSBzeW5jUXVldWUoKTtcbiAgICB9KTtcbiAgfSwgW10pO1xufVxuXG4vLyDilIDilIDilIAgT05MSU5FL09GRkxJTkUgREVURUNUSU9OIOKUgOKUgOKUgFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT25saW5lU3RhdHVzKCkge1xuICBjb25zdCB7IGlzT25saW5lLCBzZXRPbmxpbmUgfSA9IHVzZU9mZmxpbmVTdG9yZSgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBnb09ubGluZSA9ICgpID0+IHsgc2V0T25saW5lKHRydWUpOyBzeW5jUXVldWUoKTsgfTtcbiAgICBjb25zdCBnb09mZmxpbmUgPSAoKSA9PiBzZXRPbmxpbmUoZmFsc2UpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGdvT25saW5lKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGdvT2ZmbGluZSk7XG4gICAgc2V0T25saW5lKG5hdmlnYXRvci5vbkxpbmUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBnb09ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGdvT2ZmbGluZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBpc09ubGluZTtcbn1cblxuLy8g4pSA4pSA4pSAIFNZTkMgUVVFVUUg4pSA4pSA4pSAXG5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNRdWV1ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VPZmZsaW5lU3RvcmUuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0b3JlLmlzU3luY2luZyB8fCBzdG9yZS5xdWV1ZWRBY3Rpb25zLmxlbmd0aCA9PT0gMCB8fCAhbmF2aWdhdG9yLm9uTGluZSkgcmV0dXJuO1xuXG4gIHN0b3JlLnNldFN5bmNpbmcodHJ1ZSk7XG4gIGNvbnNvbGUubG9nKGBbUFdBXSBTeW5jaW5nICR7c3RvcmUucXVldWVkQWN0aW9ucy5sZW5ndGh9IHF1ZXVlZCBhY3Rpb25zLi4uYCk7XG5cbiAgY29uc3QgcXVldWUgPSBbLi4uc3RvcmUucXVldWVkQWN0aW9uc107XG4gIGxldCBzeW5jZWQgPSAwO1xuICBsZXQgZmFpbGVkID0gMDtcblxuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBxdWV1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFjdGlvbi51cmwsIHtcbiAgICAgICAgbWV0aG9kOiBhY3Rpb24ubWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBhY3Rpb24uaGVhZGVycyxcbiAgICAgICAgYm9keTogYWN0aW9uLmJvZHksXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNwb25zZS5vayB8fCByZXNwb25zZS5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgc3RvcmUucmVtb3ZlUXVldWVkQWN0aW9uKGFjdGlvbi5pZCk7XG4gICAgICAgIHN5bmNlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbGVkKys7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBOZXR3b3JrIHN0aWxsIGRvd24sIHN0b3AgdHJ5aW5nXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdG9yZS5zZXRTeW5jaW5nKGZhbHNlKTtcbiAgaWYgKHN5bmNlZCA+IDApIHN0b3JlLnNldExhc3RTeW5jKERhdGUubm93KCkpO1xuICBjb25zb2xlLmxvZyhgW1BXQV0gU3luYyBkb25lOiAke3N5bmNlZH0gb2ssICR7ZmFpbGVkfSBmYWlsZWQsICR7cXVldWUubGVuZ3RoIC0gc3luY2VkIC0gZmFpbGVkfSBwZW5kaW5nYCk7XG5cbiAgLy8gTm90aWZ5IGNsaWVudHNcbiAgaWYgKHN5bmNlZCA+IDAgJiYgJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyKSB7XG4gICAgLy8gU1cgd2lsbCBicm9hZGNhc3QgdXBkYXRlXG4gIH1cbn1cblxuLy8g4pSA4pSA4pSAIFBSRS1DQUNIRSBBUEkgREFUQSDilIDilIDilIBcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZWNhY2hlRGF0YSgpIHtcbiAgY29uc3QgY2FjaGVBcGlEYXRhID0gdXNlQ2FsbGJhY2soKHBhdGg6IHN0cmluZywgZGF0YTogYW55KSA9PiB7XG4gICAgaWYgKCEoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHJldHVybjtcbiAgICAvLyBCdWlsZCBmdWxsIFVSTCBmcm9tIHBhdGhcbiAgICBjb25zdCB1cmwgPSBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHAnKSA/IHBhdGggOiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufSR7cGF0aH1gO1xuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiAnQ0FDSEVfQVBJJywgdXJsLCBkYXRhIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2FjaGVQYWdlID0gdXNlQ2FsbGJhY2soKHVybDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCEoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikgfHwgIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIpIHJldHVybjtcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ0NBQ0hFX1BBR0UnLCB1cmwgfSk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4geyBjYWNoZUFwaURhdGEsIGNhY2hlUGFnZSB9O1xufVxuXG4vLyDilIDilIDilIAgQVVUTyBQUkUtQ0FDSEUgT04gTE9HSU4g4pSA4pSA4pSAXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBdXRvUHJlY2FjaGUoKSB7XG4gIGNvbnN0IHsgY2FjaGVBcGlEYXRhLCBjYWNoZVBhZ2UgfSA9IHVzZVByZWNhY2hlRGF0YSgpO1xuICBjb25zdCB7IGlzU2VydmljZVdvcmtlclJlYWR5IH0gPSB1c2VPZmZsaW5lU3RvcmUoKTtcblxuICBjb25zdCBwcmVjYWNoZUVzc2VudGlhbHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc1NlcnZpY2VXb3JrZXJSZWFkeSkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKCdbUFdBXSBQcmUtY2FjaGluZyBlc3NlbnRpYWwgZGF0YS4uLicpO1xuXG4gICAgLy8gQ2FjaGUga2V5IHBhZ2VzXG4gICAgWycvcG9zJywgJy9raXRjaGVuJywgJy90YWJsZXMnLCAnL2Rhc2hib2FyZCcsICcvd2FpdGVyJywgJy9sb2dpbiddLmZvckVhY2goY2FjaGVQYWdlKTtcblxuICAgIC8vIENhY2hlIEFQSSBkYXRhXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncG9zX3Rva2VuJyk7XG4gICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuXG4gICAgY29uc3QgQVBJID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgICBjb25zdCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCwgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuXG4gICAgY29uc3QgZW5kcG9pbnRzID0gW1xuICAgICAgJy9wcm9kdWN0cy9jYXRlZ29yaWVzJyxcbiAgICAgICcvcHJvZHVjdHM/bGltaXQ9MjAwJyxcbiAgICAgICcvY3VzdG9tZXJzP2xpbWl0PTEwMCcsXG4gICAgICAnL3RlbmFudHMvY3VycmVudCcsXG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgZXAgb2YgZW5kcG9pbnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUEl9JHtlcH1gLCB7IGhlYWRlcnMgfSk7XG4gICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICBjYWNoZUFwaURhdGEoYCR7QVBJfSR7ZXB9YCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggeyAvKiBvZmZsaW5lIGFscmVhZHksIHNraXAgKi8gfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdbUFdBXSBQcmUtY2FjaGUgZG9uZScpO1xuICB9LCBbaXNTZXJ2aWNlV29ya2VyUmVhZHksIGNhY2hlQXBpRGF0YSwgY2FjaGVQYWdlXSk7XG5cbiAgcmV0dXJuIHsgcHJlY2FjaGVFc3NlbnRpYWxzIH07XG59XG5cbi8vIOKUgOKUgOKUgCBJTlNUQUxMIFBST01QVCDilIDilIDilIBcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluc3RhbGxQcm9tcHQoKSB7XG4gIGNvbnN0IFtkZWZlcnJlZFByb21wdCwgc2V0RGVmZXJyZWRQcm9tcHRdID0gdXNlU3RhdGU8YW55PihudWxsKTtcbiAgY29uc3QgW2lzSW5zdGFsbGFibGUsIHNldElzSW5zdGFsbGFibGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNJbnN0YWxsZWQsIHNldElzSW5zdGFsbGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKCcoZGlzcGxheS1tb2RlOiBzdGFuZGFsb25lKScpLm1hdGNoZXMpIHtcbiAgICAgIHNldElzSW5zdGFsbGVkKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSAoZTogRXZlbnQpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldERlZmVycmVkUHJvbXB0KGUpO1xuICAgICAgc2V0SXNJbnN0YWxsYWJsZSh0cnVlKTtcbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWluc3RhbGxwcm9tcHQnLCBoYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYXBwaW5zdGFsbGVkJywgKCkgPT4geyBzZXRJc0luc3RhbGxlZCh0cnVlKTsgc2V0SXNJbnN0YWxsYWJsZShmYWxzZSk7IH0pO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5zdGFsbHByb21wdCcsIGhhbmRsZXIpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgaW5zdGFsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWRlZmVycmVkUHJvbXB0KSByZXR1cm4gZmFsc2U7XG4gICAgZGVmZXJyZWRQcm9tcHQucHJvbXB0KCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVmZXJyZWRQcm9tcHQudXNlckNob2ljZTtcbiAgICBzZXREZWZlcnJlZFByb21wdChudWxsKTtcbiAgICBzZXRJc0luc3RhbGxhYmxlKGZhbHNlKTtcbiAgICBpZiAocmVzdWx0Lm91dGNvbWUgPT09ICdhY2NlcHRlZCcpIHNldElzSW5zdGFsbGVkKHRydWUpO1xuICAgIHJldHVybiByZXN1bHQub3V0Y29tZSA9PT0gJ2FjY2VwdGVkJztcbiAgfTtcblxuICByZXR1cm4geyBpc0luc3RhbGxhYmxlLCBpc0luc3RhbGxlZCwgaW5zdGFsbCB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJjcmVhdGUiLCJRVUVVRV9LRVkiLCJsb2FkUXVldWUiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2F2ZVF1ZXVlIiwicXVldWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwidXNlT2ZmbGluZVN0b3JlIiwic2V0IiwiZ2V0IiwiaXNPbmxpbmUiLCJuYXZpZ2F0b3IiLCJvbkxpbmUiLCJpc1NlcnZpY2VXb3JrZXJSZWFkeSIsInF1ZXVlZEFjdGlvbnMiLCJpc1N5bmNpbmciLCJsYXN0U3luY0F0Iiwic2V0T25saW5lIiwidiIsInNldFNXUmVhZHkiLCJhZGRRdWV1ZWRBY3Rpb24iLCJhY3Rpb24iLCJyZW1vdmVRdWV1ZWRBY3Rpb24iLCJpZCIsImZpbHRlciIsImEiLCJjbGVhclF1ZXVlIiwic2V0U3luY2luZyIsInNldExhc3RTeW5jIiwidHMiLCJ1c2VTZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXJlZCIsImN1cnJlbnQiLCJzZXJ2aWNlV29ya2VyIiwicmVnaXN0ZXIiLCJzY29wZSIsInRoZW4iLCJyZWciLCJjb25zb2xlIiwibG9nIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm5ld1dvcmtlciIsImluc3RhbGxpbmciLCJzdGF0ZSIsInNldEludGVydmFsIiwidXBkYXRlIiwiY2F0Y2giLCJlcnIiLCJ3YXJuIiwiZXZlbnQiLCJ0eXBlIiwiZGF0YSIsIm1ldGhvZCIsInVybCIsInN5bmNRdWV1ZSIsInVzZU9ubGluZVN0YXR1cyIsImdvT25saW5lIiwiZ29PZmZsaW5lIiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN0b3JlIiwiZ2V0U3RhdGUiLCJsZW5ndGgiLCJzeW5jZWQiLCJmYWlsZWQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImJvZHkiLCJvayIsInN0YXR1cyIsIkRhdGUiLCJub3ciLCJjb250cm9sbGVyIiwidXNlUHJlY2FjaGVEYXRhIiwiY2FjaGVBcGlEYXRhIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJsb2NhdGlvbiIsIm9yaWdpbiIsInBvc3RNZXNzYWdlIiwiY2FjaGVQYWdlIiwidXNlQXV0b1ByZWNhY2hlIiwicHJlY2FjaGVFc3NlbnRpYWxzIiwiZm9yRWFjaCIsInRva2VuIiwiQVBJIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBdXRob3JpemF0aW9uIiwiZW5kcG9pbnRzIiwiZXAiLCJyZXMiLCJqc29uIiwidXNlSW5zdGFsbFByb21wdCIsImRlZmVycmVkUHJvbXB0Iiwic2V0RGVmZXJyZWRQcm9tcHQiLCJpc0luc3RhbGxhYmxlIiwic2V0SXNJbnN0YWxsYWJsZSIsImlzSW5zdGFsbGVkIiwic2V0SXNJbnN0YWxsZWQiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImhhbmRsZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJpbnN0YWxsIiwicHJvbXB0IiwicmVzdWx0IiwidXNlckNob2ljZSIsIm91dGNvbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/use-offline.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/pos-store.ts":
/*!********************************!*\
  !*** ./src/store/pos-store.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePosStore: () => (/* binding */ usePosStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./src/lib/api.ts\");\n/* harmony import */ var _lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/offline-sync */ \"(app-pages-browser)/./src/lib/offline-sync.ts\");\n\n\n\nconst usePosStore = (0,zustand__WEBPACK_IMPORTED_MODULE_2__.create)((set, get)=>({\n        user: null,\n        tenant: null,\n        isAuthenticated: false,\n        categories: [],\n        products: [],\n        selectedCategory: null,\n        searchQuery: '',\n        currentOrder: null,\n        isCreatingOrder: false,\n        heldOrders: [],\n        loading: false,\n        error: null,\n        offlineReady: false,\n        login: async (email, password)=>{\n            try {\n                const data = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.login(email, password);\n                _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(data.accessToken);\n                localStorage.setItem('pos_token', data.accessToken);\n                localStorage.setItem('pos_user', JSON.stringify(data.user));\n                localStorage.setItem('pos_tenant', JSON.stringify(data.tenant));\n                set({\n                    user: data.user,\n                    tenant: data.tenant,\n                    isAuthenticated: true\n                });\n                // Cache products for offline use after login\n                (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.refreshOfflineCache)().then(()=>set({\n                        offlineReady: true\n                    })).catch(()=>{});\n                return data;\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n                throw e;\n            }\n        },\n        logout: ()=>{\n            _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.clearToken();\n            localStorage.removeItem('pos_token');\n            localStorage.removeItem('pos_user');\n            localStorage.removeItem('pos_tenant');\n            set({\n                user: null,\n                tenant: null,\n                isAuthenticated: false,\n                currentOrder: null,\n                heldOrders: [],\n                categories: [],\n                products: []\n            });\n        },\n        restoreSession: ()=>{\n            if (false) {}\n            const token = localStorage.getItem('pos_token');\n            const user = localStorage.getItem('pos_user');\n            const tenant = localStorage.getItem('pos_tenant');\n            if (token && user && tenant) {\n                _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.setToken(token);\n                set({\n                    user: JSON.parse(user),\n                    tenant: JSON.parse(tenant),\n                    isAuthenticated: true\n                });\n            }\n        },\n        // ── OFFLINE-AWARE LOADERS ──\n        loadCategories: async ()=>{\n            try {\n                const categories = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.loadCategoriesOfflineAware)();\n                set({\n                    categories\n                });\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        loadProducts: async (categoryId, search)=>{\n            set({\n                loading: true\n            });\n            try {\n                const products = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.loadProductsOfflineAware)(categoryId, search);\n                set({\n                    products,\n                    loading: false\n                });\n            } catch (e) {\n                set({\n                    loading: false,\n                    error: e.message\n                });\n            }\n        },\n        setSelectedCategory: (id)=>{\n            set({\n                selectedCategory: id\n            });\n            get().loadProducts(id || undefined, get().searchQuery || undefined);\n        },\n        setSearchQuery: (q)=>{\n            set({\n                searchQuery: q\n            });\n            get().loadProducts(get().selectedCategory || undefined, q || undefined);\n        },\n        // ── OFFLINE-AWARE ORDER OPERATIONS ──\n        createOrder: async function() {\n            let type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'dine_in', metadata = arguments.length > 1 ? arguments[1] : void 0;\n            set({\n                isCreatingOrder: true,\n                error: null\n            });\n            try {\n                const order = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.createOrderOfflineAware)(type, metadata);\n                set({\n                    currentOrder: order,\n                    isCreatingOrder: false\n                });\n            } catch (e) {\n                set({\n                    isCreatingOrder: false,\n                    error: e.message\n                });\n            }\n        },\n        addItemToOrder: async function(productId) {\n            let quantity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, notes = arguments.length > 2 ? arguments[2] : void 0;\n            const { currentOrder } = get();\n            if (!currentOrder) return;\n            try {\n                const updated = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.addItemOfflineAware)(currentOrder, productId, quantity, notes);\n                set({\n                    currentOrder: updated\n                });\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        voidItem: async (itemId, reason)=>{\n            const { currentOrder } = get();\n            if (!currentOrder) return;\n            try {\n                const updated = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.voidItemOfflineAware)(currentOrder, itemId, reason);\n                set({\n                    currentOrder: updated\n                });\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        processPayment: async (method, amount, cashReceived)=>{\n            const { currentOrder } = get();\n            if (!currentOrder) return;\n            try {\n                const result = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.processPaymentOfflineAware)(currentOrder, method, amount, cashReceived);\n                if (result.orderStatus === 'completed') {\n                    set((s)=>({\n                            currentOrder: null,\n                            heldOrders: s.heldOrders.filter((o)=>o.id !== currentOrder.id)\n                        }));\n                } else {\n                    set({\n                        currentOrder: result.order || currentOrder\n                    });\n                }\n                return result;\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        cancelOrder: async ()=>{\n            const { currentOrder } = get();\n            if (!currentOrder) return;\n            try {\n                if (currentOrder._offline) {\n                    // Offline order — just remove from IndexedDB\n                    const { deleteOfflineOrder } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/offline-db */ \"(app-pages-browser)/./src/lib/offline-db.ts\"));\n                    await deleteOfflineOrder(currentOrder.id);\n                } else {\n                    await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.cancelOrder(currentOrder.id);\n                }\n                set((s)=>({\n                        currentOrder: null,\n                        heldOrders: s.heldOrders.filter((o)=>o.id !== currentOrder.id)\n                    }));\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        loadOrder: async (id)=>{\n            try {\n                if (id.startsWith('offline-')) {\n                    const { getOfflineOrders } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/offline-db */ \"(app-pages-browser)/./src/lib/offline-db.ts\"));\n                    const orders = await getOfflineOrders();\n                    const order = orders.find((o)=>o.id === id);\n                    if (order) set({\n                        currentOrder: order\n                    });\n                } else {\n                    const order = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.getOrder(id);\n                    set({\n                        currentOrder: order\n                    });\n                }\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        refreshOrder: async ()=>{\n            const { currentOrder } = get();\n            if (!currentOrder) return;\n            if (currentOrder._offline) return; // Offline orders don't refresh from server\n            try {\n                const order = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.getOrder(currentOrder.id);\n                set({\n                    currentOrder: order\n                });\n            } catch (e) {\n                set({\n                    error: e.message\n                });\n            }\n        },\n        // ── Hold / Park ──\n        holdCurrentOrder: ()=>{\n            const { currentOrder, heldOrders } = get();\n            if (!currentOrder) return;\n            const alreadyHeld = heldOrders.some((o)=>o.id === currentOrder.id);\n            set({\n                heldOrders: alreadyHeld ? heldOrders : [\n                    ...heldOrders,\n                    currentOrder\n                ],\n                currentOrder: null\n            });\n        },\n        resumeOrder: (order)=>{\n            const { currentOrder, heldOrders } = get();\n            let updatedHeld = [\n                ...heldOrders\n            ];\n            if (currentOrder) {\n                if (!updatedHeld.some((o)=>o.id === currentOrder.id)) {\n                    updatedHeld.push(currentOrder);\n                }\n            }\n            updatedHeld = updatedHeld.filter((o)=>o.id !== order.id);\n            set({\n                currentOrder: order,\n                heldOrders: updatedHeld\n            });\n        },\n        loadHeldOrders: async ()=>{\n            try {\n                // Load online open orders\n                let onlineOrders = [];\n                try {\n                    const openOrders = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.get('/orders/open');\n                    onlineOrders = Array.isArray(openOrders) ? openOrders.filter((o)=>{\n                        const items = Array.isArray(o.items) ? o.items : [];\n                        return items.filter((i)=>i.status !== 'voided').length > 0;\n                    }) : [];\n                } catch (e) {}\n                // Also load offline open orders\n                let offlineOrders = [];\n                try {\n                    const { getOfflineOrders } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/offline-db */ \"(app-pages-browser)/./src/lib/offline-db.ts\"));\n                    const all = await getOfflineOrders();\n                    offlineOrders = all.filter((o)=>o.status === 'open' && o.items.some((i)=>i.status === 'active'));\n                } catch (e) {}\n                const allOrders = [\n                    ...onlineOrders,\n                    ...offlineOrders\n                ];\n                set((s)=>({\n                        heldOrders: allOrders.filter((o)=>{\n                            var _s_currentOrder;\n                            return o.id !== ((_s_currentOrder = s.currentOrder) === null || _s_currentOrder === void 0 ? void 0 : _s_currentOrder.id);\n                        })\n                    }));\n            } catch (e) {}\n        },\n        clearOrder: ()=>set({\n                currentOrder: null\n            }),\n        clearError: ()=>set({\n                error: null\n            }),\n        // ── OFFLINE MANAGEMENT ──\n        initOfflineCache: async ()=>{\n            try {\n                const result = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.refreshOfflineCache)();\n                set({\n                    offlineReady: result.products > 0\n                });\n            } catch (e) {\n                set({\n                    offlineReady: false\n                });\n            }\n        },\n        syncOffline: async ()=>{\n            try {\n                const result = await (0,_lib_offline_sync__WEBPACK_IMPORTED_MODULE_1__.syncOfflineOrders)();\n                if (result.synced > 0) {\n                    console.log(\"[POS] Synced \".concat(result.synced, \" offline orders\"));\n                }\n            } catch (e) {\n                console.warn('[POS] Sync failed:', e);\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9wb3Mtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNEO0FBTUo7QUF3Q3JCLE1BQU1VLGNBQWNWLCtDQUFNQSxDQUFXLENBQUNXLEtBQUtDLE1BQVM7UUFDekRDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxpQkFBaUI7UUFDakJDLFlBQVksRUFBRTtRQUNkQyxVQUFVLEVBQUU7UUFDWkMsa0JBQWtCO1FBQ2xCQyxhQUFhO1FBQ2JDLGNBQWM7UUFDZEMsaUJBQWlCO1FBQ2pCQyxZQUFZLEVBQUU7UUFDZEMsU0FBUztRQUNUQyxPQUFPO1FBQ1BDLGNBQWM7UUFFZEMsT0FBTyxPQUFPQyxPQUFPQztZQUNuQixJQUFJO2dCQUNGLE1BQU1DLE9BQU8sTUFBTTVCLHlDQUFHQSxDQUFDeUIsS0FBSyxDQUFDQyxPQUFPQztnQkFDcEMzQix5Q0FBR0EsQ0FBQzZCLFFBQVEsQ0FBQ0QsS0FBS0UsV0FBVztnQkFDN0JDLGFBQWFDLE9BQU8sQ0FBQyxhQUFhSixLQUFLRSxXQUFXO2dCQUNsREMsYUFBYUMsT0FBTyxDQUFDLFlBQVlDLEtBQUtDLFNBQVMsQ0FBQ04sS0FBS2hCLElBQUk7Z0JBQ3pEbUIsYUFBYUMsT0FBTyxDQUFDLGNBQWNDLEtBQUtDLFNBQVMsQ0FBQ04sS0FBS2YsTUFBTTtnQkFDN0RILElBQUk7b0JBQUVFLE1BQU1nQixLQUFLaEIsSUFBSTtvQkFBRUMsUUFBUWUsS0FBS2YsTUFBTTtvQkFBRUMsaUJBQWlCO2dCQUFLO2dCQUVsRSw2Q0FBNkM7Z0JBQzdDUCxzRUFBbUJBLEdBQUc0QixJQUFJLENBQUMsSUFBTXpCLElBQUk7d0JBQUVjLGNBQWM7b0JBQUssSUFBSVksS0FBSyxDQUFDLEtBQU87Z0JBRTNFLE9BQU9SO1lBQ1QsRUFBRSxPQUFPUyxHQUFRO2dCQUFFM0IsSUFBSTtvQkFBRWEsT0FBT2MsRUFBRUMsT0FBTztnQkFBQztnQkFBSSxNQUFNRDtZQUFHO1FBQ3pEO1FBRUFFLFFB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QUFNO1lBQUk7UUFDMUM7UUFFQW1GLGFBQWE7WUFDWCxJQUFJO2dCQUNGLE1BQU1wQyxTQUFTLE1BQU0vRCxvRUFBaUJBO2dCQUN0QyxJQUFJK0QsT0FBT3FDLE1BQU0sR0FBRyxHQUFHO29CQUNyQkMsUUFBUUMsR0FBRyxDQUFDLGdCQUE4QixPQUFkdkMsT0FBT3FDLE1BQU0sRUFBQztnQkFDNUM7WUFDRixFQUFFLE9BQU92RSxHQUFHO2dCQUFFd0UsUUFBUUUsSUFBSSxDQUFDLHNCQUFzQjFFO1lBQUk7UUFDdkQ7SUFDRixJQUFJIiwic291cmNlcyI6WyIvVXNlcnMvY2FybG9zYW1vcmVzL0RvY3VtZW50cy9Qcm95ZWN0b3MvcG9zLXNhcy9hcHBzL3dlYi9zcmMvc3RvcmUvcG9zLXN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgYXBpIH0gZnJvbSAnQC9saWIvYXBpJztcbmltcG9ydCB7XG4gIGxvYWRQcm9kdWN0c09mZmxpbmVBd2FyZSwgbG9hZENhdGVnb3JpZXNPZmZsaW5lQXdhcmUsXG4gIGNyZWF0ZU9yZGVyT2ZmbGluZUF3YXJlLCBhZGRJdGVtT2ZmbGluZUF3YXJlLFxuICB2b2lkSXRlbU9mZmxpbmVBd2FyZSwgcHJvY2Vzc1BheW1lbnRPZmZsaW5lQXdhcmUsXG4gIHJlZnJlc2hPZmZsaW5lQ2FjaGUsIHN5bmNPZmZsaW5lT3JkZXJzLFxufSBmcm9tICdAL2xpYi9vZmZsaW5lLXN5bmMnO1xuXG5pbnRlcmZhY2UgUG9zU3RhdGUge1xuICB1c2VyOiBhbnkgfCBudWxsO1xuICB0ZW5hbnQ6IGFueSB8IG51bGw7XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgY2F0ZWdvcmllczogYW55W107XG4gIHByb2R1Y3RzOiBhbnlbXTtcbiAgc2VsZWN0ZWRDYXRlZ29yeTogc3RyaW5nIHwgbnVsbDtcbiAgc2VhcmNoUXVlcnk6IHN0cmluZztcbiAgY3VycmVudE9yZGVyOiBhbnkgfCBudWxsO1xuICBpc0NyZWF0aW5nT3JkZXI6IGJvb2xlYW47XG4gIGhlbGRPcmRlcnM6IGFueVtdO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgb2ZmbGluZVJlYWR5OiBib29sZWFuO1xuXG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTxhbnk+O1xuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XG4gIHJlc3RvcmVTZXNzaW9uOiAoKSA9PiB2b2lkO1xuICBsb2FkQ2F0ZWdvcmllczogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbG9hZFByb2R1Y3RzOiAoY2F0ZWdvcnlJZD86IHN0cmluZywgc2VhcmNoPzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzZXRTZWxlY3RlZENhdGVnb3J5OiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldFNlYXJjaFF1ZXJ5OiAocTogc3RyaW5nKSA9PiB2b2lkO1xuICBjcmVhdGVPcmRlcjogKHR5cGU/OiBzdHJpbmcsIG1ldGFkYXRhPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhZGRJdGVtVG9PcmRlcjogKHByb2R1Y3RJZDogc3RyaW5nLCBxdWFudGl0eT86IG51bWJlciwgbm90ZXM/OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHZvaWRJdGVtOiAoaXRlbUlkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcm9jZXNzUGF5bWVudDogKG1ldGhvZDogc3RyaW5nLCBhbW91bnQ6IG51bWJlciwgY2FzaFJlY2VpdmVkPzogbnVtYmVyKSA9PiBQcm9taXNlPGFueT47XG4gIGNhbmNlbE9yZGVyOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsb2FkT3JkZXI6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZWZyZXNoT3JkZXI6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGNsZWFyT3JkZXI6ICgpID0+IHZvaWQ7XG4gIGNsZWFyRXJyb3I6ICgpID0+IHZvaWQ7XG4gIGhvbGRDdXJyZW50T3JkZXI6ICgpID0+IHZvaWQ7XG4gIHJlc3VtZU9yZGVyOiAob3JkZXI6IGFueSkgPT4gdm9pZDtcbiAgbG9hZEhlbGRPcmRlcnM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGluaXRPZmZsaW5lQ2FjaGU6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHN5bmNPZmZsaW5lOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgY29uc3QgdXNlUG9zU3RvcmUgPSBjcmVhdGU8UG9zU3RhdGU+KChzZXQsIGdldCkgPT4gKHtcbiAgdXNlcjogbnVsbCxcbiAgdGVuYW50OiBudWxsLFxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICBjYXRlZ29yaWVzOiBbXSxcbiAgcHJvZHVjdHM6IFtdLFxuICBzZWxlY3RlZENhdGVnb3J5OiBudWxsLFxuICBzZWFyY2hRdWVyeTogJycsXG4gIGN1cnJlbnRPcmRlcjogbnVsbCxcbiAgaXNDcmVhdGluZ09yZGVyOiBmYWxzZSxcbiAgaGVsZE9yZGVyczogW10sXG4gIGxvYWRpbmc6IGZhbHNlLFxuICBlcnJvcjogbnVsbCxcbiAgb2ZmbGluZVJlYWR5OiBmYWxzZSxcblxuICBsb2dpbjogYXN5bmMgKGVtYWlsLCBwYXNzd29yZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpLmxvZ2luKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICBhcGkuc2V0VG9rZW4oZGF0YS5hY2Nlc3NUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncG9zX3Rva2VuJywgZGF0YS5hY2Nlc3NUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncG9zX3VzZXInLCBKU09OLnN0cmluZ2lmeShkYXRhLnVzZXIpKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwb3NfdGVuYW50JywgSlNPTi5zdHJpbmdpZnkoZGF0YS50ZW5hbnQpKTtcbiAgICAgIHNldCh7IHVzZXI6IGRhdGEudXNlciwgdGVuYW50OiBkYXRhLnRlbmFudCwgaXNBdXRoZW50aWNhdGVkOiB0cnVlIH0pO1xuXG4gICAgICAvLyBDYWNoZSBwcm9kdWN0cyBmb3Igb2ZmbGluZSB1c2UgYWZ0ZXIgbG9naW5cbiAgICAgIHJlZnJlc2hPZmZsaW5lQ2FjaGUoKS50aGVuKCgpID0+IHNldCh7IG9mZmxpbmVSZWFkeTogdHJ1ZSB9KSkuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHsgc2V0KHsgZXJyb3I6IGUubWVzc2FnZSB9KTsgdGhyb3cgZTsgfVxuICB9LFxuXG4gIGxvZ291dDogKCkgPT4ge1xuICAgIGFwaS5jbGVhclRva2VuKCk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Bvc190b2tlbicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwb3NfdXNlcicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwb3NfdGVuYW50Jyk7XG4gICAgc2V0KHsgdXNlcjogbnVsbCwgdGVuYW50OiBudWxsLCBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLCBjdXJyZW50T3JkZXI6IG51bGwsIGhlbGRPcmRlcnM6IFtdLCBjYXRlZ29yaWVzOiBbXSwgcHJvZHVjdHM6IFtdIH0pO1xuICB9LFxuXG4gIHJlc3RvcmVTZXNzaW9uOiAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncG9zX3Rva2VuJyk7XG4gICAgY29uc3QgdXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwb3NfdXNlcicpO1xuICAgIGNvbnN0IHRlbmFudCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwb3NfdGVuYW50Jyk7XG4gICAgaWYgKHRva2VuICYmIHVzZXIgJiYgdGVuYW50KSB7XG4gICAgICBhcGkuc2V0VG9rZW4odG9rZW4pO1xuICAgICAgc2V0KHsgdXNlcjogSlNPTi5wYXJzZSh1c2VyKSwgdGVuYW50OiBKU09OLnBhcnNlKHRlbmFudCksIGlzQXV0aGVudGljYXRlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8g4pSA4pSAIE9GRkxJTkUtQVdBUkUgTE9BREVSUyDilIDilIBcblxuICBsb2FkQ2F0ZWdvcmllczogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYXRlZ29yaWVzID0gYXdhaXQgbG9hZENhdGVnb3JpZXNPZmZsaW5lQXdhcmUoKTtcbiAgICAgIHNldCh7IGNhdGVnb3JpZXMgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7IHNldCh7IGVycm9yOiBlLm1lc3NhZ2UgfSk7IH1cbiAgfSxcblxuICBsb2FkUHJvZHVjdHM6IGFzeW5jIChjYXRlZ29yeUlkLCBzZWFyY2gpID0+IHtcbiAgICBzZXQoeyBsb2FkaW5nOiB0cnVlIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9kdWN0cyA9IGF3YWl0IGxvYWRQcm9kdWN0c09mZmxpbmVBd2FyZShjYXRlZ29yeUlkLCBzZWFyY2gpO1xuICAgICAgc2V0KHsgcHJvZHVjdHMsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkgeyBzZXQoeyBsb2FkaW5nOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9KTsgfVxuICB9LFxuXG4gIHNldFNlbGVjdGVkQ2F0ZWdvcnk6IChpZCkgPT4ge1xuICAgIHNldCh7IHNlbGVjdGVkQ2F0ZWdvcnk6IGlkIH0pO1xuICAgIGdldCgpLmxvYWRQcm9kdWN0cyhpZCB8fCB1bmRlZmluZWQsIGdldCgpLnNlYXJjaFF1ZXJ5IHx8IHVuZGVmaW5lZCk7XG4gIH0sXG5cbiAgc2V0U2VhcmNoUXVlcnk6IChxKSA9PiB7XG4gICAgc2V0KHsgc2VhcmNoUXVlcnk6IHEgfSk7XG4gICAgZ2V0KCkubG9hZFByb2R1Y3RzKGdldCgpLnNlbGVjdGVkQ2F0ZWdvcnkgfHwgdW5kZWZpbmVkLCBxIHx8IHVuZGVmaW5lZCk7XG4gIH0sXG5cbiAgLy8g4pSA4pSAIE9GRkxJTkUtQVdBUkUgT1JERVIgT1BFUkFUSU9OUyDilIDilIBcblxuICBjcmVhdGVPcmRlcjogYXN5bmMgKHR5cGUgPSAnZGluZV9pbicsIG1ldGFkYXRhKSA9PiB7XG4gICAgc2V0KHsgaXNDcmVhdGluZ09yZGVyOiB0cnVlLCBlcnJvcjogbnVsbCB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3JkZXIgPSBhd2FpdCBjcmVhdGVPcmRlck9mZmxpbmVBd2FyZSh0eXBlLCBtZXRhZGF0YSk7XG4gICAgICBzZXQoeyBjdXJyZW50T3JkZXI6IG9yZGVyLCBpc0NyZWF0aW5nT3JkZXI6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkgeyBzZXQoeyBpc0NyZWF0aW5nT3JkZXI6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH0pOyB9XG4gIH0sXG5cbiAgYWRkSXRlbVRvT3JkZXI6IGFzeW5jIChwcm9kdWN0SWQsIHF1YW50aXR5ID0gMSwgbm90ZXMpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnRPcmRlciB9ID0gZ2V0KCk7XG4gICAgaWYgKCFjdXJyZW50T3JkZXIpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IGF3YWl0IGFkZEl0ZW1PZmZsaW5lQXdhcmUoY3VycmVudE9yZGVyLCBwcm9kdWN0SWQsIHF1YW50aXR5LCBub3Rlcyk7XG4gICAgICBzZXQoeyBjdXJyZW50T3JkZXI6IHVwZGF0ZWQgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7IHNldCh7IGVycm9yOiBlLm1lc3NhZ2UgfSk7IH1cbiAgfSxcblxuICB2b2lkSXRlbTogYXN5bmMgKGl0ZW1JZCwgcmVhc29uKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50T3JkZXIgfSA9IGdldCgpO1xuICAgIGlmICghY3VycmVudE9yZGVyKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCB2b2lkSXRlbU9mZmxpbmVBd2FyZShjdXJyZW50T3JkZXIsIGl0ZW1JZCwgcmVhc29uKTtcbiAgICAgIHNldCh7IGN1cnJlbnRPcmRlcjogdXBkYXRlZCB9KTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHsgc2V0KHsgZXJyb3I6IGUubWVzc2FnZSB9KTsgfVxuICB9LFxuXG4gIHByb2Nlc3NQYXltZW50OiBhc3luYyAobWV0aG9kLCBhbW91bnQsIGNhc2hSZWNlaXZlZCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudE9yZGVyIH0gPSBnZXQoKTtcbiAgICBpZiAoIWN1cnJlbnRPcmRlcikgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzUGF5bWVudE9mZmxpbmVBd2FyZShjdXJyZW50T3JkZXIsIG1ldGhvZCwgYW1vdW50LCBjYXNoUmVjZWl2ZWQpO1xuICAgICAgaWYgKHJlc3VsdC5vcmRlclN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgc2V0KHMgPT4gKHsgY3VycmVudE9yZGVyOiBudWxsLCBoZWxkT3JkZXJzOiBzLmhlbGRPcmRlcnMuZmlsdGVyKG8gPT4gby5pZCAhPT0gY3VycmVudE9yZGVyLmlkKSB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXQoeyBjdXJyZW50T3JkZXI6IHJlc3VsdC5vcmRlciB8fCBjdXJyZW50T3JkZXIgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGU6IGFueSkgeyBzZXQoeyBlcnJvcjogZS5tZXNzYWdlIH0pOyB9XG4gIH0sXG5cbiAgY2FuY2VsT3JkZXI6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnRPcmRlciB9ID0gZ2V0KCk7XG4gICAgaWYgKCFjdXJyZW50T3JkZXIpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgaWYgKGN1cnJlbnRPcmRlci5fb2ZmbGluZSkge1xuICAgICAgICAvLyBPZmZsaW5lIG9yZGVyIOKAlCBqdXN0IHJlbW92ZSBmcm9tIEluZGV4ZWREQlxuICAgICAgICBjb25zdCB7IGRlbGV0ZU9mZmxpbmVPcmRlciB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9vZmZsaW5lLWRiJyk7XG4gICAgICAgIGF3YWl0IGRlbGV0ZU9mZmxpbmVPcmRlcihjdXJyZW50T3JkZXIuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgYXBpLmNhbmNlbE9yZGVyKGN1cnJlbnRPcmRlci5pZCk7XG4gICAgICB9XG4gICAgICBzZXQocyA9PiAoeyBjdXJyZW50T3JkZXI6IG51bGwsIGhlbGRPcmRlcnM6IHMuaGVsZE9yZGVycy5maWx0ZXIobyA9PiBvLmlkICE9PSBjdXJyZW50T3JkZXIuaWQpIH0pKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHsgc2V0KHsgZXJyb3I6IGUubWVzc2FnZSB9KTsgfVxuICB9LFxuXG4gIGxvYWRPcmRlcjogYXN5bmMgKGlkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpZC5zdGFydHNXaXRoKCdvZmZsaW5lLScpKSB7XG4gICAgICAgIGNvbnN0IHsgZ2V0T2ZmbGluZU9yZGVycyB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9vZmZsaW5lLWRiJyk7XG4gICAgICAgIGNvbnN0IG9yZGVycyA9IGF3YWl0IGdldE9mZmxpbmVPcmRlcnMoKTtcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBvcmRlcnMuZmluZChvID0+IG8uaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKG9yZGVyKSBzZXQoeyBjdXJyZW50T3JkZXI6IG9yZGVyIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBhd2FpdCBhcGkuZ2V0T3JkZXIoaWQpO1xuICAgICAgICBzZXQoeyBjdXJyZW50T3JkZXI6IG9yZGVyIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkgeyBzZXQoeyBlcnJvcjogZS5tZXNzYWdlIH0pOyB9XG4gIH0sXG5cbiAgcmVmcmVzaE9yZGVyOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50T3JkZXIgfSA9IGdldCgpO1xuICAgIGlmICghY3VycmVudE9yZGVyKSByZXR1cm47XG4gICAgaWYgKGN1cnJlbnRPcmRlci5fb2ZmbGluZSkgcmV0dXJuOyAvLyBPZmZsaW5lIG9yZGVycyBkb24ndCByZWZyZXNoIGZyb20gc2VydmVyXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9yZGVyID0gYXdhaXQgYXBpLmdldE9yZGVyKGN1cnJlbnRPcmRlci5pZCk7XG4gICAgICBzZXQoeyBjdXJyZW50T3JkZXI6IG9yZGVyIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkgeyBzZXQoeyBlcnJvcjogZS5tZXNzYWdlIH0pOyB9XG4gIH0sXG5cbiAgLy8g4pSA4pSAIEhvbGQgLyBQYXJrIOKUgOKUgFxuICBob2xkQ3VycmVudE9yZGVyOiAoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50T3JkZXIsIGhlbGRPcmRlcnMgfSA9IGdldCgpO1xuICAgIGlmICghY3VycmVudE9yZGVyKSByZXR1cm47XG4gICAgY29uc3QgYWxyZWFkeUhlbGQgPSBoZWxkT3JkZXJzLnNvbWUobyA9PiBvLmlkID09PSBjdXJyZW50T3JkZXIuaWQpO1xuICAgIHNldCh7IGhlbGRPcmRlcnM6IGFscmVhZHlIZWxkID8gaGVsZE9yZGVycyA6IFsuLi5oZWxkT3JkZXJzLCBjdXJyZW50T3JkZXJdLCBjdXJyZW50T3JkZXI6IG51bGwgfSk7XG4gIH0sXG5cbiAgcmVzdW1lT3JkZXI6IChvcmRlcikgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudE9yZGVyLCBoZWxkT3JkZXJzIH0gPSBnZXQoKTtcbiAgICBsZXQgdXBkYXRlZEhlbGQgPSBbLi4uaGVsZE9yZGVyc107XG4gICAgaWYgKGN1cnJlbnRPcmRlcikge1xuICAgICAgaWYgKCF1cGRhdGVkSGVsZC5zb21lKG8gPT4gby5pZCA9PT0gY3VycmVudE9yZGVyLmlkKSkge1xuICAgICAgICB1cGRhdGVkSGVsZC5wdXNoKGN1cnJlbnRPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZWRIZWxkID0gdXBkYXRlZEhlbGQuZmlsdGVyKG8gPT4gby5pZCAhPT0gb3JkZXIuaWQpO1xuICAgIHNldCh7IGN1cnJlbnRPcmRlcjogb3JkZXIsIGhlbGRPcmRlcnM6IHVwZGF0ZWRIZWxkIH0pO1xuICB9LFxuXG4gIGxvYWRIZWxkT3JkZXJzOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgb25saW5lIG9wZW4gb3JkZXJzXG4gICAgICBsZXQgb25saW5lT3JkZXJzOiBhbnlbXSA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3Blbk9yZGVyczogYW55ID0gYXdhaXQgYXBpLmdldCgnL29yZGVycy9vcGVuJyk7XG4gICAgICAgIG9ubGluZU9yZGVycyA9IEFycmF5LmlzQXJyYXkob3Blbk9yZGVycylcbiAgICAgICAgICA/IG9wZW5PcmRlcnMuZmlsdGVyKChvOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5pc0FycmF5KG8uaXRlbXMpID8gby5pdGVtcyA6IFtdO1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpOiBhbnkpID0+IGkuc3RhdHVzICE9PSAndm9pZGVkJykubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiBbXTtcbiAgICAgIH0gY2F0Y2gge31cblxuICAgICAgLy8gQWxzbyBsb2FkIG9mZmxpbmUgb3BlbiBvcmRlcnNcbiAgICAgIGxldCBvZmZsaW5lT3JkZXJzOiBhbnlbXSA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBnZXRPZmZsaW5lT3JkZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL29mZmxpbmUtZGInKTtcbiAgICAgICAgY29uc3QgYWxsID0gYXdhaXQgZ2V0T2ZmbGluZU9yZGVycygpO1xuICAgICAgICBvZmZsaW5lT3JkZXJzID0gYWxsLmZpbHRlcihvID0+IG8uc3RhdHVzID09PSAnb3BlbicgJiYgby5pdGVtcy5zb21lKGkgPT4gaS5zdGF0dXMgPT09ICdhY3RpdmUnKSk7XG4gICAgICB9IGNhdGNoIHt9XG5cbiAgICAgIGNvbnN0IGFsbE9yZGVycyA9IFsuLi5vbmxpbmVPcmRlcnMsIC4uLm9mZmxpbmVPcmRlcnNdO1xuICAgICAgc2V0KHMgPT4gKHtcbiAgICAgICAgaGVsZE9yZGVyczogYWxsT3JkZXJzLmZpbHRlcigobzogYW55KSA9PiBvLmlkICE9PSBzLmN1cnJlbnRPcmRlcj8uaWQpLFxuICAgICAgfSkpO1xuICAgIH0gY2F0Y2gge31cbiAgfSxcblxuICBjbGVhck9yZGVyOiAoKSA9PiBzZXQoeyBjdXJyZW50T3JkZXI6IG51bGwgfSksXG4gIGNsZWFyRXJyb3I6ICgpID0+IHNldCh7IGVycm9yOiBudWxsIH0pLFxuXG4gIC8vIOKUgOKUgCBPRkZMSU5FIE1BTkFHRU1FTlQg4pSA4pSAXG5cbiAgaW5pdE9mZmxpbmVDYWNoZTogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoT2ZmbGluZUNhY2hlKCk7XG4gICAgICBzZXQoeyBvZmZsaW5lUmVhZHk6IHJlc3VsdC5wcm9kdWN0cyA+IDAgfSk7XG4gICAgfSBjYXRjaCB7IHNldCh7IG9mZmxpbmVSZWFkeTogZmFsc2UgfSk7IH1cbiAgfSxcblxuICBzeW5jT2ZmbGluZTogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jT2ZmbGluZU9yZGVycygpO1xuICAgICAgaWYgKHJlc3VsdC5zeW5jZWQgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbUE9TXSBTeW5jZWQgJHtyZXN1bHQuc3luY2VkfSBvZmZsaW5lIG9yZGVyc2ApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS53YXJuKCdbUE9TXSBTeW5jIGZhaWxlZDonLCBlKTsgfVxuICB9LFxufSkpO1xuIl0sIm5hbWVzIjpbImNyZWF0ZSIsImFwaSIsImxvYWRQcm9kdWN0c09mZmxpbmVBd2FyZSIsImxvYWRDYXRlZ29yaWVzT2ZmbGluZUF3YXJlIiwiY3JlYXRlT3JkZXJPZmZsaW5lQXdhcmUiLCJhZGRJdGVtT2ZmbGluZUF3YXJlIiwidm9pZEl0ZW1PZmZsaW5lQXdhcmUiLCJwcm9jZXNzUGF5bWVudE9mZmxpbmVBd2FyZSIsInJlZnJlc2hPZmZsaW5lQ2FjaGUiLCJzeW5jT2ZmbGluZU9yZGVycyIsInVzZVBvc1N0b3JlIiwic2V0IiwiZ2V0IiwidXNlciIsInRlbmFudCIsImlzQXV0aGVudGljYXRlZCIsImNhdGVnb3JpZXMiLCJwcm9kdWN0cyIsInNlbGVjdGVkQ2F0ZWdvcnkiLCJzZWFyY2hRdWVyeSIsImN1cnJlbnRPcmRlciIsImlzQ3JlYXRpbmdPcmRlciIsImhlbGRPcmRlcnMiLCJsb2FkaW5nIiwiZXJyb3IiLCJvZmZsaW5lUmVhZHkiLCJsb2dpbiIsImVtYWlsIiwicGFzc3dvcmQiLCJkYXRhIiwic2V0VG9rZW4iLCJhY2Nlc3NUb2tlbiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwidGhlbiIsImNhdGNoIiwiZSIsIm1lc3NhZ2UiLCJsb2dvdXQiLCJjbGVhclRva2VuIiwicmVtb3ZlSXRlbSIsInJlc3RvcmVTZXNzaW9uIiwidG9rZW4iLCJnZXRJdGVtIiwicGFyc2UiLCJsb2FkQ2F0ZWdvcmllcyIsImxvYWRQcm9kdWN0cyIsImNhdGVnb3J5SWQiLCJzZWFyY2giLCJzZXRTZWxlY3RlZENhdGVnb3J5IiwiaWQiLCJ1bmRlZmluZWQiLCJzZXRTZWFyY2hRdWVyeSIsInEiLCJjcmVhdGVPcmRlciIsInR5cGUiLCJtZXRhZGF0YSIsIm9yZGVyIiwiYWRkSXRlbVRvT3JkZXIiLCJwcm9kdWN0SWQiLCJxdWFudGl0eSIsIm5vdGVzIiwidXBkYXRlZCIsInZvaWRJdGVtIiwiaXRlbUlkIiwicmVhc29uIiwicHJvY2Vzc1BheW1lbnQiLCJtZXRob2QiLCJhbW91bnQiLCJjYXNoUmVjZWl2ZWQiLCJyZXN1bHQiLCJvcmRlclN0YXR1cyIsInMiLCJmaWx0ZXIiLCJvIiwiY2FuY2VsT3JkZXIiLCJfb2ZmbGluZSIsImRlbGV0ZU9mZmxpbmVPcmRlciIsImxvYWRPcmRlciIsInN0YXJ0c1dpdGgiLCJnZXRPZmZsaW5lT3JkZXJzIiwib3JkZXJzIiwiZmluZCIsImdldE9yZGVyIiwicmVmcmVzaE9yZGVyIiwiaG9sZEN1cnJlbnRPcmRlciIsImFscmVhZHlIZWxkIiwic29tZSIsInJlc3VtZU9yZGVyIiwidXBkYXRlZEhlbGQiLCJwdXNoIiwibG9hZEhlbGRPcmRlcnMiLCJvbmxpbmVPcmRlcnMiLCJvcGVuT3JkZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbXMiLCJpIiwic3RhdHVzIiwibGVuZ3RoIiwib2ZmbGluZU9yZGVycyIsImFsbCIsImFsbE9yZGVycyIsImNsZWFyT3JkZXIiLCJjbGVhckVycm9yIiwiaW5pdE9mZmxpbmVDYWNoZSIsInN5bmNPZmZsaW5lIiwic3luY2VkIiwiY29uc29sZSIsImxvZyIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/pos-store.ts\n"));

/***/ })

});